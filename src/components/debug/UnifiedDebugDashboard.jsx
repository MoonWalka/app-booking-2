/**
 * üöÄ Dashboard de Debug Unifi√© TourCraft
 * Combine tous les outils de monitoring et debug en une interface unique
 * - Performance Firebase
 * - Cache de persistance
 * - Tests et diagnostics
 * - Monitoring temps r√©el
 * - Diagnostic de navigation
 * - Tests de navigation
 */

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useLocation, useNavigationType, useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import FirestoreService from '@/services/firestoreService';
import persistenceService, { CACHE_STRATEGIES } from '@/services/persistenceService';
import { utilityCache } from '@/utils/networkStabilizer';
import ContactAssociationsDebug from './ContactAssociationsDebug';
import AssociationsAudit from './AssociationsAudit';
import RelancesAutomatiquesTest from './RelancesAutomatiquesTest';
import { useOrganization } from '@/context/OrganizationContext';
import { collection, query, where, getDocs, db } from '@/services/firebase-service';

const UnifiedDebugDashboard = () => {
  // √âtats principaux
  const [isVisible, setIsVisible] = useState(false);
  const [activeTab, setActiveTab] = useState('cache');
  const [refreshInterval, setRefreshInterval] = useState(1000);
  const [isExpanded, setIsExpanded] = useState(false);
  
  // √âtats pour Firebase Performance
  const [firebaseStats, setFirebaseStats] = useState({});
  const [lastRequests, setLastRequests] = useState([]);
  const [slowRequests, setSlowRequests] = useState([]);
  
  // √âtats pour Cache Persistance
  const [persistenceStats, setPersistenceStats] = useState({});
  const [testResults, setTestResults] = useState([]);
  
  // √âtats pour Utility Cache
  const [utilityStats, setUtilityStats] = useState({});
  
  // √âtats pour Navigation Diagnostic
  const location = useLocation();
  const navigationType = useNavigationType();
  const navigate = useNavigate();
  const { currentUser, loading } = useAuth();
  
  const [navLogs, setNavLogs] = useState([]);
  const [navRenderCount, setNavRenderCount] = useState(0);
  const [navAuthRenderCount, setNavAuthRenderCount] = useState(0);
  const [navLocationChanges, setNavLocationChanges] = useState(0);
  const [navErrors, setNavErrors] = useState([]);
  const [navTestResults, setNavTestResults] = useState([]);
  const [isRunningNavTests, setIsRunningNavTests] = useState(false);
  
  // √âtats pour Deep Analysis
  const [hookAnalysis, setHookAnalysis] = useState([]);
  const [componentTree, setComponentTree] = useState([]);
  const [performanceMetrics, setPerformanceMetrics] = useState({});
  const [errorPatterns, setErrorPatterns] = useState([]);
  
  // √âtats pour Multi-Org Isolation Test
  const [multiOrgTestResults, setMultiOrgTestResults] = useState(null);
  const [isTestingMultiOrg, setIsTestingMultiOrg] = useState(false);
  const { currentOrganization } = useOrganization();
  
  const navRenderCountRef = useRef(0);
  const navAuthRenderCountRef = useRef(0);
  const lastLocationRef = useRef(null);
  const lastAuthStateRef = useRef(null);
  const startTimeRef = useRef(Date.now());
  
  // üîÑ Mise √† jour des statistiques Firebase
  const updateFirebaseStats = useCallback(() => {
    if (FirestoreService.getCacheStats) {
      setFirebaseStats(FirestoreService.getCacheStats());
    }
  }, []);

  // üîÑ Mise √† jour des statistiques de persistance
  const updatePersistenceStats = useCallback(() => {
    const stats = persistenceService.getStats();
    setPersistenceStats({
      ...stats,
      timestamp: Date.now()
    });
  }, []);

  // üîÑ Mise √† jour des statistiques utilitaires
  const updateUtilityStats = useCallback(() => {
    setUtilityStats({
      size: utilityCache.cache?.size || 0,
      timestamp: Date.now()
    });
  }, []);

  // üîÑ Mise √† jour globale
  const updateAllStats = useCallback(() => {
    updateFirebaseStats();
    updatePersistenceStats();
    updateUtilityStats();
  }, [updateFirebaseStats, updatePersistenceStats, updateUtilityStats]);

  // üß≠ Fonctions de diagnostic de navigation
  // Fonction helper pour cr√©er des logs de navigation de mani√®re stable
  const createNavLogEntry = useCallback((message, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    return {
      id: Date.now() + Math.random(),
      timestamp,
      message,
      type,
      location: location.pathname
    };
  }, [location.pathname]);

  const addNavLog = useCallback((message, type = 'info') => {
    const logEntry = createNavLogEntry(message, type);
    
    setNavLogs(prev => [...prev.slice(-49), logEntry]); // Garder seulement les 50 derniers logs
    
    if (type === 'error') {
      setNavErrors(prev => [...prev.slice(-9), logEntry]); // Garder les 10 derni√®res erreurs
    }
  }, [createNavLogEntry]);

  const clearNavLogs = useCallback(() => {
    setNavLogs([]);
    setNavErrors([]);
    setNavRenderCount(0);
    setNavAuthRenderCount(0);
    setNavLocationChanges(0);
    navRenderCountRef.current = 0;
    navAuthRenderCountRef.current = 0;
    startTimeRef.current = Date.now();
  }, []);

  const getNavDiagnostic = useCallback(() => {
    const issues = [];
    
    if (navRenderCount > 30) {
      issues.push(`üö® Trop de rendus (${navRenderCount}) - Possible boucle infinie`);
    }
    
    if (navAuthRenderCount > 15) {
      issues.push(`üö® Auth instable (${navAuthRenderCount} changements) - Probl√®me dans AuthContext`);
    }
    
    if (navErrors.length > 5) {
      issues.push(`üö® Trop d'erreurs (${navErrors.length}) - V√©rifier la console`);
    }
    
    const recentRenders = navLogs.filter(log => 
      log.type === 'render' && 
      Date.now() - new Date(`1970-01-01T${log.timestamp}`).getTime() < 5000
    ).length;
    
    if (recentRenders > 10) {
      issues.push(`üö® Rendus trop fr√©quents (${recentRenders} en 5s)`);
    }
    
    return issues;
  }, [navRenderCount, navAuthRenderCount, navErrors.length, navLogs]);

  // üß™ Tests de navigation
  const addNavTestResult = useCallback((test, status, details = '') => {
    const result = {
      id: Date.now(),
      test,
      status, // 'success', 'error', 'warning', 'running'
      details,
      timestamp: new Date().toLocaleTimeString()
    };
    setNavTestResults(prev => [...prev, result]);
    return result;
  }, []);

  const runQuickNavTest = useCallback(() => {
    setNavTestResults([]);
    
    // Test rapide de d√©tection d'√©l√©ments
    const contactsElements = document.querySelectorAll('[href*="/contacts"]');
    addNavTestResult('D√©tection liens contacts', contactsElements.length > 0 ? 'success' : 'warning', 
      `${contactsElements.length} liens trouv√©s`);
    
    const clickableElements = document.querySelectorAll('.clickableRow, [data-testid*="item"]');
    addNavTestResult('D√©tection √©l√©ments cliquables', clickableElements.length > 0 ? 'success' : 'warning', 
      `${clickableElements.length} √©l√©ments trouv√©s`);
    
    const tableElements = document.querySelectorAll('table, .table');
    addNavTestResult('D√©tection tables', tableElements.length > 0 ? 'success' : 'warning', 
      `${tableElements.length} tables trouv√©es`);
    
    // Test de la console pour les erreurs
    const hasConsoleErrors = window.console._errors && window.console._errors.length > 0;
    addNavTestResult('V√©rification erreurs console', hasConsoleErrors ? 'error' : 'success', 
      hasConsoleErrors ? 'Erreurs d√©tect√©es' : 'Pas d\'erreurs');
  }, [addNavTestResult]);

  const runFullNavTest = useCallback(async () => {
    setIsRunningNavTests(true);
    setNavTestResults([]);
    
    try {
      // Test 1: Navigation vers les contacts
      addNavTestResult('Navigation vers /contacts', 'running');
      await new Promise(resolve => setTimeout(resolve, 100));
      
      try {
        navigate('/contacts');
        await new Promise(resolve => setTimeout(resolve, 500));
        addNavTestResult('Navigation vers /contacts', 'success', 'Navigation r√©ussie');
      } catch (error) {
        addNavTestResult('Navigation vers /contacts', 'error', error.message);
      }
      
      // Test 2: Attendre le chargement
      addNavTestResult('Attente du chargement de la liste', 'running');
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // V√©rifier si des √©l√©ments sont pr√©sents
      const listElements = document.querySelectorAll('[data-testid="contact-item"], .contact-item, .clickableRow');
      if (listElements.length > 0) {
        addNavTestResult('Chargement de la liste', 'success', `${listElements.length} √©l√©ments trouv√©s`);
        
        // Test 3: Clic sur le premier √©l√©ment
        addNavTestResult('Test de clic sur un √©l√©ment', 'running');
        try {
          const firstElement = listElements[0];
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          
          firstElement.dispatchEvent(clickEvent);
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // V√©rifier si la navigation a eu lieu
          if (location.pathname.includes('/contacts/') && location.pathname !== '/contacts') {
            addNavTestResult('Test de clic sur un √©l√©ment', 'success', `Navigation vers ${location.pathname}`);
          } else {
            addNavTestResult('Test de clic sur un √©l√©ment', 'warning', 'Pas de navigation d√©tect√©e');
          }
        } catch (error) {
          addNavTestResult('Test de clic sur un √©l√©ment', 'error', error.message);
        }
      } else {
        addNavTestResult('Chargement de la liste', 'error', 'Aucun √©l√©ment de liste trouv√©');
      }
      
      // Test 4: Navigation vers d'autres modules
      const modules = [
        { path: '/concerts', name: 'Concerts' },
        { path: '/artistes', name: 'Artistes' },
        { path: '/lieux', name: 'Lieux' }
      ];
      
      for (const module of modules) {
        addNavTestResult(`Navigation vers ${module.name}`, 'running');
        try {
          navigate(module.path);
          await new Promise(resolve => setTimeout(resolve, 300));
          addNavTestResult(`Navigation vers ${module.name}`, 'success', `Route: ${location.pathname}`);
        } catch (error) {
          addNavTestResult(`Navigation vers ${module.name}`, 'error', error.message);
        }
      }
      
      // Test 5: Retour au dashboard
      addNavTestResult('Retour au dashboard', 'running');
      try {
        navigate('/');
        await new Promise(resolve => setTimeout(resolve, 300));
        addNavTestResult('Retour au dashboard', 'success', 'Navigation r√©ussie');
      } catch (error) {
        addNavTestResult('Retour au dashboard', 'error', error.message);
      }
      
    } catch (error) {
      addNavTestResult('Test g√©n√©ral', 'error', `Erreur globale: ${error.message}`);
    } finally {
      setIsRunningNavTests(false);
    }
  }, [navigate, location.pathname, addNavTestResult]);

  // üìä Monitoring des requ√™tes Firebase
  useEffect(() => {
    if (!isVisible || process.env.NODE_ENV === 'production') return;

    // Patch Firebase pour monitoring
    const originalGetDocument = FirestoreService.getDocument;
    const originalGetDocuments = FirestoreService.getDocuments;

    const monitorRequest = async (type, collection, id, func, ...args) => {
      const start = performance.now();
      let result;
      
      try {
        result = await func(...args);
        const end = performance.now();
        const duration = end - start;
        
        const requestDetails = {
          type,
          collection,
          id: id || 'N/A',
          duration: Math.round(duration),
          timestamp: new Date().toISOString(),
          fromCache: false, // TODO: d√©tecter cache hit
          slow: duration > 300
        };
        
        setLastRequests(prev => [requestDetails, ...prev].slice(0, 20));
        
        if (duration > 300) {
          setSlowRequests(prev => [requestDetails, ...prev].slice(0, 10));
        }
        
        return result;
      } catch (error) {
        console.error(`Erreur dans ${type}:`, error);
        throw error;
      }
    };

    // Remplacer les m√©thodes
    if (originalGetDocument) {
      FirestoreService.getDocument = async (collectionName, documentId, ...args) => {
        return monitorRequest('getDocument', collectionName, documentId, originalGetDocument.bind(FirestoreService), collectionName, documentId, ...args);
      };
    }

    if (originalGetDocuments) {
      FirestoreService.getDocuments = async (collectionName, queryOptions, ...args) => {
        return monitorRequest('getDocuments', collectionName, null, originalGetDocuments.bind(FirestoreService), collectionName, queryOptions, ...args);
      };
    }

    return () => {
      // Restaurer les fonctions originales
      if (originalGetDocument) FirestoreService.getDocument = originalGetDocument;
      if (originalGetDocuments) FirestoreService.getDocuments = originalGetDocuments;
    };
  }, [isVisible]);

  // ‚è∞ Auto-refresh
  useEffect(() => {
    if (!isVisible) return;

    updateAllStats();
    const interval = setInterval(updateAllStats, refreshInterval);
    return () => clearInterval(interval);
  }, [isVisible, refreshInterval, updateAllStats]);

  // üß≠ Monitoring de navigation - Compteur de rendus
  useEffect(() => {
    if (!isVisible) return;
    
    navRenderCountRef.current += 1;
    setNavRenderCount(navRenderCountRef.current);
    
    const now = Date.now();
    const elapsed = now - startTimeRef.current;
    
    addNavLog(`üîÑ Rendu #${navRenderCountRef.current} (${elapsed}ms depuis le d√©but)`, 'render');
    
    // D√©tecter les boucles de rendu
    if (navRenderCountRef.current > 50) {
      addNavLog(`üö® ALERTE: Plus de 50 rendus d√©tect√©s! Possible boucle infinie`, 'error');
    }
  }, [isVisible, addNavLog]);

  // üß≠ Surveillance des changements d'authentification
  useEffect(() => {
    if (!isVisible) return;
    
    navAuthRenderCountRef.current += 1;
    setNavAuthRenderCount(navAuthRenderCountRef.current);
    
    const authState = { currentUser: !!currentUser, loading };
    const authStateStr = JSON.stringify(authState);
    
    if (lastAuthStateRef.current !== authStateStr) {
      addNavLog(`üîê Auth chang√©: ${authStateStr}`, 'auth');
      lastAuthStateRef.current = authStateStr;
      
      // D√©tecter les boucles d'auth
      if (navAuthRenderCountRef.current > 20) {
        addNavLog(`üö® ALERTE: Plus de 20 changements d'auth! Possible boucle`, 'error');
      }
    }
  }, [currentUser, loading, isVisible, addNavLog]);

  // üß≠ Surveillance des changements de location
  useEffect(() => {
    if (!isVisible) return;
    
    const locationStr = `${location.pathname}${location.search}${location.hash}`;
    
    if (lastLocationRef.current !== locationStr) {
      setNavLocationChanges(prev => prev + 1);
      addNavLog(`üß≠ Navigation: ${locationStr} (${navigationType})`, 'navigation');
      lastLocationRef.current = locationStr;
    }
  }, [location, navigationType, isVisible, addNavLog]);

  // üß≠ Surveillance des erreurs console
  useEffect(() => {
    if (!isVisible) return;
    
    const originalError = console.error;
    const originalWarn = console.warn;
    
    console.error = (...args) => {
      addNavLog(`‚ùå Erreur: ${args.join(' ')}`, 'error');
      originalError.apply(console, args);
    };
    
    console.warn = (...args) => {
      const message = args.join(' ');
      if (message.includes('Maximum update depth') || message.includes('boucle')) {
        addNavLog(`‚ö†Ô∏è Warning critique: ${message}`, 'error');
      } else {
        addNavLog(`‚ö†Ô∏è Warning: ${message}`, 'warning');
      }
      originalWarn.apply(console, args);
    };
    
    return () => {
      console.error = originalError;
      console.warn = originalWarn;
    };
  }, [isVisible, addNavLog]);

  // üß™ Tests de performance
  const runPerformanceTest = useCallback(async () => {
    const testName = `Test ${new Date().toLocaleTimeString()}`;
    const iterations = 1000;
    
    persistenceService.resetStats();
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      persistenceService.set(`test_${i}`, { data: i, timestamp: Date.now() }, CACHE_STRATEGIES.MEMORY_ONLY);
      persistenceService.get(`test_${i}`, CACHE_STRATEGIES.MEMORY_ONLY);
    }
    
    const endTime = performance.now();
    const duration = endTime - startTime;
    const finalStats = persistenceService.getStats();
    
    const result = {
      name: testName,
      duration: Math.round(duration * 100) / 100,
      iterations,
      opsPerSecond: Math.round((iterations * 2 / duration) * 1000),
      hitRate: finalStats.hitRate,
      memorySize: finalStats.memorySize
    };
    
    setTestResults(prev => [result, ...prev.slice(0, 9)]);
    persistenceService.cleanup();
  }, []);

  // üß™ Test des strat√©gies
  const testAllStrategies = useCallback(() => {
    const strategies = [
      { strategy: CACHE_STRATEGIES.MEMORY_ONLY, name: 'MEMORY_ONLY' },
      { strategy: CACHE_STRATEGIES.SESSION_ONLY, name: 'SESSION_ONLY' },
      { strategy: CACHE_STRATEGIES.LOCAL_ONLY, name: 'LOCAL_ONLY' },
      { strategy: CACHE_STRATEGIES.MEMORY_SESSION, name: 'MEMORY_SESSION' },
      { strategy: CACHE_STRATEGIES.MEMORY_LOCAL, name: 'MEMORY_LOCAL' },
      { strategy: CACHE_STRATEGIES.TTL, name: 'TTL' }
    ];
    
    const results = strategies.map(({ strategy, name }) => {
      const testData = { test: name, timestamp: Date.now() };
      const key = `strategy_test_${name}`;
      
      const setResult = persistenceService.set(key, testData, strategy);
      const getResult = persistenceService.get(key, strategy);
      
      return {
        strategy: name,
        setSuccess: setResult,
        getSuccess: getResult !== null,
        dataIntegrity: JSON.stringify(getResult) === JSON.stringify(testData)
      };
    });
    
    console.log('üß™ Tests de strat√©gies:', results);
    return results;
  }, []);

  // üßπ Nettoyage
  const cleanup = useCallback(() => {
    // const cleaned = await cleanupService.performCleanup(); // R√©sultat de d√©bogage - logs supprim√©s
    persistenceService.cleanup();
    if (FirestoreService.clearCache) {
      FirestoreService.clearCache();
    }
    updateAllStats();
  }, [updateAllStats]);

  // üîÑ Reset
  const resetAll = useCallback(() => {
    persistenceService.resetStats();
    setTestResults([]);
    setLastRequests([]);
    setSlowRequests([]);
    // Reset navigation data
    clearNavLogs();
    setNavTestResults([]);
    updateAllStats();
  }, [updateAllStats, clearNavLogs]);

  // üé® Styles
  const styles = {
    toggleButton: {
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      zIndex: 9999
    },
    showButton: {
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      padding: '12px 16px',
      borderRadius: '25px',
      cursor: 'pointer',
      boxShadow: '0 4px 12px rgba(0,123,255,0.3)',
      fontSize: '14px',
      fontWeight: 'bold'
    },
    dashboard: {
      position: 'fixed',
      top: '10px',
      right: '10px',
      width: isExpanded ? 'min(95vw, 1200px)' : 'min(90vw, 800px)', // Responsive width
      maxWidth: isExpanded ? '1200px' : '800px',
      minWidth: '600px',
      height: isExpanded ? 'min(95vh, 900px)' : 'min(90vh, 800px)', // Responsive height
      maxHeight: isExpanded ? '95vh' : '90vh',
      backgroundColor: 'white',
      borderRadius: '12px',
      boxShadow: '0 8px 32px rgba(0,0,0,0.15)',
      zIndex: 9998,
      overflow: 'hidden',
      border: '1px solid #e0e0e0',
      display: 'flex',
      flexDirection: 'column',
      transition: 'all 0.3s ease'
    },
    header: {
      padding: '16px 20px',
      backgroundColor: '#f8f9fa',
      borderBottom: '1px solid #e0e0e0',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    },
    title: {
      margin: 0,
      fontSize: '18px',
      fontWeight: 'bold',
      color: '#333'
    },
    controls: {
      display: 'flex',
      gap: '8px',
      alignItems: 'center'
    },
    select: {
      padding: '4px 8px',
      borderRadius: '4px',
      border: '1px solid #ddd',
      fontSize: '12px'
    },
    button: {
      padding: '6px 12px',
      borderRadius: '6px',
      border: 'none',
      backgroundColor: '#007bff',
      color: 'white',
      cursor: 'pointer',
      fontSize: '12px',
      fontWeight: 'bold'
    },
    closeButton: {
      padding: '4px 8px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: '#dc3545',
      color: 'white',
      cursor: 'pointer',
      fontSize: '14px'
    },
    tabs: {
      display: 'flex',
      backgroundColor: '#f8f9fa',
      borderBottom: '1px solid #e0e0e0',
      flexWrap: 'wrap', // Allow wrapping on small screens
      minHeight: 'auto'
    },
    tab: {
      flex: '1 1 auto',
      minWidth: '80px', // Minimum width for each tab
      padding: '8px 12px', // Reduced padding for better fit
      textAlign: 'center',
      cursor: 'pointer',
      borderBottom: '3px solid transparent',
      fontSize: '12px', // Smaller font for better fit
      fontWeight: 'bold',
      transition: 'all 0.2s',
      whiteSpace: 'nowrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    },
    activeTab: {
      borderBottom: '3px solid #007bff',
      backgroundColor: 'white',
      color: '#007bff'
    },
    content: {
      padding: '16px',
      flex: 1, // Take remaining space
      overflow: 'auto',
      minHeight: 0 // Important for flex scrolling
    },
    grid: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: '16px',
      marginBottom: '16px'
    },
    card: {
      padding: '16px',
      backgroundColor: '#f8f9fa',
      borderRadius: '8px',
      border: '1px solid #e0e0e0'
    },
    cardTitle: {
      margin: '0 0 12px 0',
      fontSize: '14px',
      fontWeight: 'bold',
      color: '#333'
    },
    stat: {
      display: 'flex',
      justifyContent: 'space-between',
      marginBottom: '8px',
      fontSize: '13px'
    },
    label: {
      color: '#666'
    },
    value: {
      fontWeight: 'bold',
      color: '#333'
    },
    table: {
      width: '100%',
      borderCollapse: 'collapse',
      fontSize: '12px'
    },
    th: {
      padding: '8px',
      textAlign: 'left',
      borderBottom: '2px solid #e0e0e0',
      backgroundColor: '#f8f9fa',
      fontWeight: 'bold'
    },
    td: {
      padding: '6px 8px',
      borderBottom: '1px solid #e0e0e0'
    },
    slowRow: {
      backgroundColor: '#fff3f3'
    }
  };

  // Fonction utilitaire pour les couleurs de statut
  const getStatusColor = (status) => {
    switch (status) {
      case 'success': return '#00ff00';
      case 'error': return '#ff0000';
      case 'warning': return '#ffaa00';
      case 'running': return '#00aaff';
      default: return '#ffffff';
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case 'success': return '‚úÖ';
      case 'error': return '‚ùå';
      case 'warning': return '‚ö†Ô∏è';
      case 'running': return '‚è≥';
      default: return 'üìù';
    }
  };

  const getLogColor = (type) => {
    switch (type) {
      case 'error': return '#ff4444';
      case 'warning': return '#ffaa00';
      case 'auth': return '#4444ff';
      case 'navigation': return '#44ff44';
      case 'render': return '#888888';
      default: return '#000000';
    }
  };

  // üî¨ Fonctions d'analyse approfondie
  const analyzeHooks = useCallback(() => {
    const analysis = [];
    
    // Analyser les hooks React dans la page actuelle
    const reactFiberNode = document.querySelector('#root')?._reactInternalFiber || 
                          document.querySelector('#root')?._reactInternals;
    
    if (reactFiberNode) {
      analysis.push({
        type: 'React Fiber',
        status: 'detected',
        details: 'React Fiber tree accessible'
      });
    }
    
    // Analyser les erreurs de hooks
    const hookErrors = navLogs.filter(log => 
      log.message.includes('hook') || 
      log.message.includes('useEffect') || 
      log.message.includes('useCallback') ||
      log.message.includes('dependency')
    );
    
    analysis.push({
      type: 'Hook Errors',
      status: hookErrors.length > 0 ? 'warning' : 'success',
      details: `${hookErrors.length} erreurs de hooks d√©tect√©es`,
      data: hookErrors
    });
    
    // Analyser les re-rendus excessifs
    const excessiveRenders = navLogs.filter(log => 
      log.type === 'render' && 
      Date.now() - new Date(`1970-01-01T${log.timestamp}`).getTime() < 10000
    );
    
    analysis.push({
      type: 'Excessive Renders',
      status: excessiveRenders.length > 20 ? 'error' : excessiveRenders.length > 10 ? 'warning' : 'success',
      details: `${excessiveRenders.length} rendus en 10 secondes`,
      data: excessiveRenders
    });
    
    setHookAnalysis(analysis);
  }, [navLogs]);

  const analyzeComponentTree = useCallback(() => {
    const tree = [];
    
    // Analyser l'arbre des composants via React DevTools si disponible
    if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
      tree.push({
        component: 'React DevTools',
        status: 'available',
        details: 'React DevTools d√©tect√©'
      });
    }
    
    // Analyser les composants avec des erreurs
    const errorComponents = [...new Set(navLogs
      .filter(log => log.type === 'error')
      .map(log => {
        const match = log.message.match(/(\w+)@http/);
        return match ? match[1] : 'Unknown';
      })
    )];
    
    errorComponents.forEach(component => {
      tree.push({
        component,
        status: 'error',
        details: 'Composant avec erreurs d√©tect√©es'
      });
    });
    
    setComponentTree(tree);
  }, [navLogs]);

  const analyzePerformance = useCallback(() => {
    const metrics = {};
    
    // Analyser les m√©triques de performance
    if (performance.getEntriesByType) {
      const navigationEntries = performance.getEntriesByType('navigation');
      if (navigationEntries.length > 0) {
        const nav = navigationEntries[0];
        metrics.domContentLoaded = Math.round(nav.domContentLoadedEventEnd - nav.domContentLoadedEventStart);
        metrics.loadComplete = Math.round(nav.loadEventEnd - nav.loadEventStart);
        metrics.totalLoadTime = Math.round(nav.loadEventEnd - nav.fetchStart);
      }
      
      const resourceEntries = performance.getEntriesByType('resource');
      metrics.resourceCount = resourceEntries.length;
      metrics.slowResources = resourceEntries.filter(r => r.duration > 1000).length;
    }
    
    // Analyser les m√©triques de m√©moire si disponibles
    if (performance.memory) {
      metrics.memoryUsed = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
      metrics.memoryTotal = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
      metrics.memoryLimit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
    }
    
    setPerformanceMetrics(metrics);
  }, []);

  const analyzeErrorPatterns = useCallback(() => {
    const patterns = [];
    
    // Grouper les erreurs par type
    const errorGroups = {};
    navErrors.forEach(error => {
      const errorType = error.message.split(':')[0] || 'Unknown';
      if (!errorGroups[errorType]) {
        errorGroups[errorType] = [];
      }
      errorGroups[errorType].push(error);
    });
    
    Object.entries(errorGroups).forEach(([type, errors]) => {
      patterns.push({
        pattern: type,
        count: errors.length,
        frequency: errors.length / Math.max(navErrors.length, 1),
        lastOccurrence: errors[errors.length - 1]?.timestamp,
        status: errors.length > 5 ? 'critical' : errors.length > 2 ? 'warning' : 'info'
      });
    });
    
    // Analyser les patterns temporels
    const timePatterns = navLogs.reduce((acc, log) => {
      const minute = new Date(`1970-01-01T${log.timestamp}`).getMinutes();
      acc[minute] = (acc[minute] || 0) + 1;
      return acc;
    }, {});
    
    const maxActivity = Math.max(...Object.values(timePatterns));
    if (maxActivity > 50) {
      patterns.push({
        pattern: 'High Activity Burst',
        count: maxActivity,
        frequency: 1,
        status: 'warning',
        details: 'Pic d\'activit√© d√©tect√©'
      });
    }
    
    setErrorPatterns(patterns);
  }, [navErrors, navLogs]);

  const runDeepAnalysis = useCallback(() => {
    analyzeHooks();
    analyzeComponentTree();
    analyzePerformance();
    analyzeErrorPatterns();
  }, [analyzeHooks, analyzeComponentTree, analyzePerformance, analyzeErrorPatterns]);

  // üîí Test d'isolation multi-organisation
  const runMultiOrgIsolationTest = useCallback(async () => {
    setIsTestingMultiOrg(true);
    setMultiOrgTestResults(null);
    
    try {
      const results = {
        timestamp: new Date().toISOString(),
        currentOrganization: currentOrganization ? {
          id: currentOrganization.id,
          name: currentOrganization.name
        } : null,
        tests: [],
        issues: [],
        summary: {
          totalDocuments: 0,
          organizationDocuments: 0,
          leakedDocuments: 0,
          missingOrgIdDocuments: 0
        }
      };
      
      if (!currentOrganization?.id) {
        results.issues.push({
          type: 'error',
          message: 'Aucune organisation s√©lectionn√©e',
          severity: 'critical'
        });
        setMultiOrgTestResults(results);
        return;
      }
      
      // Collections √† tester
      const collectionsToTest = [
        'concerts',
        'contacts',
        'artistes',
        'lieux',
        'structures',
        'contrats',
        'formulaires',
        'relances'
      ];
      
      for (const collectionName of collectionsToTest) {
        try {
          // Test 1: Requ√™te sans filtre
          const allQuery = query(collection(db, collectionName));
          const allDocs = await getDocs(allQuery);
          
          // Test 2: Requ√™te avec filtre organizationId
          const orgQuery = query(
            collection(db, collectionName),
            where('organizationId', '==', currentOrganization.id)
          );
          const orgDocs = await getDocs(orgQuery);
          
          // Analyser les r√©sultats
          const organizations = new Set();
          let missingOrgId = 0;
          
          allDocs.forEach(doc => {
            const data = doc.data();
            if (data.organizationId) {
              organizations.add(data.organizationId);
            } else {
              missingOrgId++;
            }
          });
          
          const testResult = {
            collection: collectionName,
            totalDocuments: allDocs.size,
            organizationDocuments: orgDocs.size,
            leakedDocuments: allDocs.size - orgDocs.size,
            missingOrgId: missingOrgId,
            organizationsFound: Array.from(organizations),
            status: allDocs.size === orgDocs.size ? 'success' : 'warning'
          };
          
          results.tests.push(testResult);
          results.summary.totalDocuments += allDocs.size;
          results.summary.organizationDocuments += orgDocs.size;
          results.summary.leakedDocuments += testResult.leakedDocuments;
          results.summary.missingOrgIdDocuments += missingOrgId;
          
          // D√©tecter les probl√®mes
          if (testResult.leakedDocuments > 0) {
            results.issues.push({
              type: 'warning',
              collection: collectionName,
              message: `${testResult.leakedDocuments} documents d'autres organisations sont accessibles`,
              severity: 'high'
            });
          }
          
          if (missingOrgId > 0) {
            results.issues.push({
              type: 'info',
              collection: collectionName,
              message: `${missingOrgId} documents sans organizationId`,
              severity: 'medium'
            });
          }
          
          if (organizations.size > 1) {
            results.issues.push({
              type: 'error',
              collection: collectionName,
              message: `Plusieurs organisations d√©tect√©es (${organizations.size})`,
              severity: 'critical',
              organizations: Array.from(organizations)
            });
          }
          
        } catch (error) {
          results.tests.push({
            collection: collectionName,
            error: error.message,
            status: 'error'
          });
          
          results.issues.push({
            type: 'error',
            collection: collectionName,
            message: `Erreur lors du test: ${error.message}`,
            severity: 'medium'
          });
        }
      }
      
      // Calculer le score de s√©curit√©
      const securityScore = results.summary.organizationDocuments > 0 
        ? Math.round((results.summary.organizationDocuments / results.summary.totalDocuments) * 100)
        : 100;
      
      results.securityScore = securityScore;
      results.status = securityScore === 100 ? 'secure' : securityScore >= 90 ? 'warning' : 'critical';
      
      setMultiOrgTestResults(results);
      
    } catch (error) {
      console.error('Erreur lors du test multi-org:', error);
      setMultiOrgTestResults({
        error: error.message,
        timestamp: new Date().toISOString()
      });
    } finally {
      setIsTestingMultiOrg(false);
    }
  }, [currentOrganization]);

  if (process.env.NODE_ENV === 'production') {
    return null;
  }

  if (!isVisible) {
    return (
      <div style={styles.toggleButton}>
        <button 
          onClick={() => setIsVisible(true)}
          style={styles.showButton}
          title="Ouvrir le Dashboard de Debug"
        >
          üöÄ Debug Dashboard
        </button>
      </div>
    );
  }

  return (
    <div style={styles.dashboard}>
      {/* Header */}
      <div style={styles.header}>
        <h3 style={styles.title}>üöÄ Debug Dashboard</h3>
        <div style={styles.controls}>
          <select 
            value={refreshInterval} 
            onChange={(e) => setRefreshInterval(Number(e.target.value))}
            style={styles.select}
          >
            <option value={500}>0.5s</option>
            <option value={1000}>1s</option>
            <option value={2000}>2s</option>
            <option value={5000}>5s</option>
          </select>
          <button 
            onClick={() => setIsExpanded(!isExpanded)} 
            style={{...styles.button, backgroundColor: isExpanded ? '#28a745' : '#6c757d'}}
            title={isExpanded ? 'R√©duire' : 'Agrandir'}
          >
            {isExpanded ? 'üìâ' : 'üìà'}
          </button>
          <button onClick={cleanup} style={styles.button}>üßπ</button>
          <button onClick={resetAll} style={styles.button}>üîÑ</button>
          <button onClick={() => setIsVisible(false)} style={styles.closeButton}>‚úï</button>
        </div>
      </div>

      {/* Tabs */}
      <div style={styles.tabs}>
        {[
          { id: 'cache', label: 'üìä Cache', shortLabel: 'üìä' },
          { id: 'firebase', label: 'üî• Firebase', shortLabel: 'üî•' },
          { id: 'tests', label: 'üß™ Tests', shortLabel: 'üß™' },
          { id: 'contacts', label: 'üë• Contacts', shortLabel: 'üë•' },
          { id: 'audit', label: 'üîç Audit', shortLabel: 'üîç' },
          { id: 'requests', label: 'üì° Requ√™tes', shortLabel: 'üì°' },
          { id: 'navigation', label: 'üß≠ Navigation', shortLabel: 'üß≠' },
          { id: 'navtests', label: 'üß™ Nav Tests', shortLabel: 'üß™¬≤' },
          { id: 'relances', label: 'ü§ñ Relances Auto', shortLabel: 'ü§ñ' },
          { id: 'deepanalysis', label: 'üî¨ Deep Analysis', shortLabel: 'üî¨' },
          { id: 'multiorg', label: 'üîí Multi-Org', shortLabel: 'üîí' }
        ].map(tab => (
          <div
            key={tab.id}
            style={{
              ...styles.tab,
              ...(activeTab === tab.id ? styles.activeTab : {})
            }}
            onClick={() => setActiveTab(tab.id)}
            title={tab.label} // Tooltip avec le nom complet
          >
            {isExpanded ? tab.label : tab.shortLabel}
          </div>
        ))}
      </div>

      {/* Content */}
      <div style={styles.content}>
        {/* Onglet Cache */}
        {activeTab === 'cache' && (
          <div>
            <div style={styles.grid}>
              <div style={styles.card}>
                <h4 style={styles.cardTitle}>üìä Persistance Service</h4>
                <div style={styles.stat}>
                  <span style={styles.label}>Hits:</span>
                  <span style={styles.value}>{persistenceStats.hits || 0}</span>
                </div>
                <div style={styles.stat}>
                  <span style={styles.label}>Misses:</span>
                  <span style={styles.value}>{persistenceStats.misses || 0}</span>
                </div>
                <div style={styles.stat}>
                  <span style={styles.label}>Hit Rate:</span>
                  <span style={styles.value}>
                    {((persistenceStats.hitRate || 0) * 100).toFixed(1)}%
                  </span>
                </div>
                <div style={styles.stat}>
                  <span style={styles.label}>Memory Size:</span>
                  <span style={styles.value}>{persistenceStats.memorySize || 0}</span>
                </div>
              </div>

              <div style={styles.card}>
                <h4 style={styles.cardTitle}>üîß Utility Cache</h4>
                <div style={styles.stat}>
                  <span style={styles.label}>Size:</span>
                  <span style={styles.value}>{utilityStats.size || 0}</span>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Onglet Firebase */}
        {activeTab === 'firebase' && (
          <div>
            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üî• Firebase Cache</h4>
              <div style={styles.stat}>
                <span style={styles.label}>Hit Rate:</span>
                <span style={styles.value}>{firebaseStats.hitRate || '0%'}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>Hits:</span>
                <span style={styles.value}>{firebaseStats.hits || 0}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>Misses:</span>
                <span style={styles.value}>{firebaseStats.misses || 0}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>Size:</span>
                <span style={styles.value}>{firebaseStats.size || 0}</span>
              </div>
            </div>
          </div>
        )}

        {/* Onglet Tests */}
        {activeTab === 'tests' && (
          <div>
            <div style={{ marginBottom: '16px' }}>
              <button onClick={runPerformanceTest} style={styles.button}>
                üöÄ Test Performance (1000 ops)
              </button>
              <button onClick={testAllStrategies} style={{...styles.button, marginLeft: '8px'}}>
                üß™ Test Strat√©gies
              </button>
            </div>

            {testResults.length > 0 && (
              <div style={styles.card}>
                <h4 style={styles.cardTitle}>üìà R√©sultats Tests</h4>
                <table style={styles.table}>
                  <thead>
                    <tr>
                      <th style={styles.th}>Test</th>
                      <th style={styles.th}>Dur√©e (ms)</th>
                      <th style={styles.th}>Ops/sec</th>
                      <th style={styles.th}>Hit Rate</th>
                    </tr>
                  </thead>
                  <tbody>
                    {testResults.map((result, index) => (
                      <tr key={index}>
                        <td style={styles.td}>{result.name}</td>
                        <td style={styles.td}>{result.duration}</td>
                        <td style={styles.td}>{result.opsPerSecond}</td>
                        <td style={styles.td}>{(result.hitRate * 100).toFixed(1)}%</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}

        {/* Onglet Requ√™tes */}
        {/* Onglet Contacts Debug */}
        {activeTab === 'contacts' && (
          <div>
            <ContactAssociationsDebug />
          </div>
        )}

        {/* Onglet Audit Associations */}
        {activeTab === 'audit' && (
          <div>
            <AssociationsAudit />
          </div>
        )}

        {activeTab === 'requests' && (
          <div>
            {/* Requ√™tes r√©centes */}
            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üì° Requ√™tes R√©centes</h4>
              <table style={styles.table}>
                <thead>
                  <tr>
                    <th style={styles.th}>Type</th>
                    <th style={styles.th}>Collection</th>
                    <th style={styles.th}>Dur√©e (ms)</th>
                    <th style={styles.th}>Cache</th>
                  </tr>
                </thead>
                <tbody>
                  {lastRequests.slice(0, 10).map((req, index) => (
                    <tr key={index} style={req.slow ? styles.slowRow : {}}>
                      <td style={styles.td}>{req.type}</td>
                      <td style={styles.td}>{req.collection}</td>
                      <td style={styles.td}>{req.duration}</td>
                      <td style={styles.td}>{req.fromCache ? '‚úì' : '‚úó'}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            {/* Requ√™tes lentes */}
            {slowRequests.length > 0 && (
              <div style={{...styles.card, marginTop: '16px'}}>
                <h4 style={styles.cardTitle}>üêå Requ√™tes Lentes (&gt;300ms)</h4>
                <table style={styles.table}>
                  <thead>
                    <tr>
                      <th style={styles.th}>Type</th>
                      <th style={styles.th}>Collection</th>
                      <th style={styles.th}>Dur√©e (ms)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {slowRequests.map((req, index) => (
                      <tr key={index} style={styles.slowRow}>
                        <td style={styles.td}>{req.type}</td>
                        <td style={styles.td}>{req.collection}</td>
                        <td style={styles.td}>
                          {req.duration}
                          {req.duration > 1000 && <span style={{marginLeft: '5px'}}>üî•</span>}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}

        {/* Onglet Navigation */}
        {activeTab === 'navigation' && (
          <div>
            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üß≠ Navigation Diagnostic</h4>
              <div style={styles.stat}>
                <span style={styles.label}>Navigations:</span>
                <span style={styles.value}>{navRenderCount}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>Erreurs:</span>
                <span style={styles.value}>{navErrors.length}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>Changements de location:</span>
                <span style={styles.value}>{navLocationChanges}</span>
              </div>
            </div>

            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üß≠ Logs de Navigation</h4>
              <table style={styles.table}>
                <thead>
                  <tr>
                    <th style={styles.th}>Type</th>
                    <th style={styles.th}>Message</th>
                    <th style={styles.th}>Location</th>
                  </tr>
                </thead>
                <tbody>
                  {navLogs.map((log, index) => (
                    <tr key={index} style={{backgroundColor: getLogColor(log.type)}}>
                      <td style={styles.td}>{getStatusIcon(log.type)}</td>
                      <td style={styles.td}>{log.message}</td>
                      <td style={styles.td}>{log.location}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üß≠ Erreurs de Navigation</h4>
              <table style={styles.table}>
                <thead>
                  <tr>
                    <th style={styles.th}>Erreur</th>
                    <th style={styles.th}>Message</th>
                    <th style={styles.th}>Date</th>
                  </tr>
                </thead>
                <tbody>
                  {navErrors.map((error, index) => (
                    <tr key={index} style={{backgroundColor: getStatusColor('error')}}>
                      <td style={styles.td}>{getStatusIcon('error')}</td>
                      <td style={styles.td}>{error.message}</td>
                      <td style={styles.td}>{error.timestamp}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}

        {/* Onglet Nav Tests */}
        {activeTab === 'navtests' && (
          <div>
            <div style={{ marginBottom: '16px' }}>
              <button 
                onClick={runQuickNavTest} 
                disabled={isRunningNavTests}
                style={styles.button}
              >
                üöÄ Test Rapide
              </button>
              <button 
                onClick={runFullNavTest} 
                disabled={isRunningNavTests}
                style={{...styles.button, marginLeft: '8px'}}
              >
                {isRunningNavTests ? '‚è≥ En cours...' : 'üß™ Test Complet'}
              </button>
              <button 
                onClick={() => setNavTestResults([])} 
                style={{...styles.button, marginLeft: '8px', backgroundColor: '#6c757d'}}
              >
                üßπ Clear
              </button>
            </div>

            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üìç √âtat Actuel</h4>
              <div style={styles.stat}>
                <span style={styles.label}>Route actuelle:</span>
                <span style={styles.value}>{location.pathname}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>User connect√©:</span>
                <span style={styles.value}>{currentUser ? '‚úÖ' : '‚ùå'}</span>
              </div>
              <div style={styles.stat}>
                <span style={styles.label}>Loading:</span>
                <span style={styles.value}>{loading ? '‚è≥' : '‚úÖ'}</span>
              </div>
            </div>

            {/* Diagnostic automatique */}
            {getNavDiagnostic().length > 0 && (
              <div style={{...styles.card, backgroundColor: '#fff3f3', marginTop: '16px'}}>
                <h4 style={styles.cardTitle}>üö® PROBL√àMES D√âTECT√âS</h4>
                {getNavDiagnostic().map((issue, index) => (
                  <div key={index} style={{ color: '#dc3545', marginBottom: '8px' }}>
                    {issue}
                  </div>
                ))}
              </div>
            )}

            {/* R√©sultats des tests */}
            {navTestResults.length > 0 && (
              <div style={{...styles.card, marginTop: '16px'}}>
                <h4 style={styles.cardTitle}>üìã R√©sultats des Tests</h4>
                <table style={styles.table}>
                  <thead>
                    <tr>
                      <th style={styles.th}>Test</th>
                      <th style={styles.th}>Statut</th>
                      <th style={styles.th}>D√©tails</th>
                      <th style={styles.th}>Heure</th>
                    </tr>
                  </thead>
                  <tbody>
                    {navTestResults.map((result, index) => (
                      <tr key={index} style={{
                        backgroundColor: result.status === 'error' ? '#fff3f3' : 
                                       result.status === 'warning' ? '#fff8e1' :
                                       result.status === 'success' ? '#f3fff3' : 'transparent'
                      }}>
                        <td style={styles.td}>{result.test}</td>
                        <td style={styles.td}>
                          <span style={{ color: getStatusColor(result.status) }}>
                            {getStatusIcon(result.status)} {result.status}
                          </span>
                        </td>
                        <td style={styles.td}>{result.details}</td>
                        <td style={styles.td}>{result.timestamp}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {navTestResults.length === 0 && (
              <div style={{...styles.card, marginTop: '16px', textAlign: 'center', color: '#666'}}>
                <p>Aucun test ex√©cut√©. Cliquez sur "Test Rapide" pour un diagnostic rapide ou "Test Complet" pour une analyse compl√®te de la navigation.</p>
              </div>
            )}
          </div>
        )}

        {/* Onglet Relances Automatiques */}
        {activeTab === 'relances' && (
          <div>
            <RelancesAutomatiquesTest />
          </div>
        )}

        {/* Onglet Deep Analysis */}
        {activeTab === 'deepanalysis' && (
          <div>
            <div style={{ marginBottom: '16px' }}>
              <button 
                onClick={runDeepAnalysis} 
                style={styles.button}
              >
                üî¨ Lancer l'analyse approfondie
              </button>
              <button 
                onClick={() => {
                  setHookAnalysis([]);
                  setComponentTree([]);
                  setPerformanceMetrics({});
                  setErrorPatterns([]);
                }} 
                style={{...styles.button, marginLeft: '8px', backgroundColor: '#6c757d'}}
              >
                üßπ Clear
              </button>
            </div>

            {/* Analyse des Hooks */}
            {hookAnalysis.length > 0 && (
              <div style={{...styles.card, marginBottom: '16px'}}>
                <h4 style={styles.cardTitle}>ü™ù Analyse des Hooks</h4>
                <table style={styles.table}>
                  <thead>
                    <tr>
                      <th style={styles.th}>Type</th>
                      <th style={styles.th}>Statut</th>
                      <th style={styles.th}>D√©tails</th>
                    </tr>
                  </thead>
                  <tbody>
                    {hookAnalysis.map((analysis, index) => (
                      <tr key={index} style={{
                        backgroundColor: analysis.status === 'error' ? '#fff3f3' : 
                                       analysis.status === 'warning' ? '#fff8e1' :
                                       analysis.status === 'success' ? '#f3fff3' : 'transparent'
                      }}>
                        <td style={styles.td}>{analysis.type}</td>
                        <td style={styles.td}>
                          <span style={{ color: getStatusColor(analysis.status) }}>
                            {getStatusIcon(analysis.status)} {analysis.status}
                          </span>
                        </td>
                        <td style={styles.td}>{analysis.details}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {/* Arbre des Composants */}
            {componentTree.length > 0 && (
              <div style={{...styles.card, marginBottom: '16px'}}>
                <h4 style={styles.cardTitle}>üå≥ Arbre des Composants</h4>
                <table style={styles.table}>
                  <thead>
                    <tr>
                      <th style={styles.th}>Composant</th>
                      <th style={styles.th}>Statut</th>
                      <th style={styles.th}>D√©tails</th>
                    </tr>
                  </thead>
                  <tbody>
                    {componentTree.map((comp, index) => (
                      <tr key={index} style={{
                        backgroundColor: comp.status === 'error' ? '#fff3f3' : 
                                       comp.status === 'warning' ? '#fff8e1' :
                                       comp.status === 'available' ? '#f3fff3' : 'transparent'
                      }}>
                        <td style={styles.td}>{comp.component}</td>
                        <td style={styles.td}>
                          <span style={{ color: getStatusColor(comp.status) }}>
                            {getStatusIcon(comp.status)} {comp.status}
                          </span>
                        </td>
                        <td style={styles.td}>{comp.details}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {/* M√©triques de Performance */}
            {Object.keys(performanceMetrics).length > 0 && (
              <div style={{...styles.card, marginBottom: '16px'}}>
                <h4 style={styles.cardTitle}>‚ö° M√©triques de Performance</h4>
                <div style={styles.grid}>
                  {Object.entries(performanceMetrics).map(([key, value]) => (
                    <div key={key} style={styles.stat}>
                      <span style={styles.label}>{key}:</span>
                      <span style={styles.value}>
                        {typeof value === 'number' ? 
                          (key.includes('memory') ? `${value} MB` : 
                           key.includes('Time') ? `${value} ms` : value) : 
                          value}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Patterns d'Erreurs */}
            {errorPatterns.length > 0 && (
              <div style={{...styles.card, marginBottom: '16px'}}>
                <h4 style={styles.cardTitle}>üîç Patterns d'Erreurs</h4>
                <table style={styles.table}>
                  <thead>
                    <tr>
                      <th style={styles.th}>Pattern</th>
                      <th style={styles.th}>Occurrences</th>
                      <th style={styles.th}>Fr√©quence</th>
                      <th style={styles.th}>Statut</th>
                    </tr>
                  </thead>
                  <tbody>
                    {errorPatterns.map((pattern, index) => (
                      <tr key={index} style={{
                        backgroundColor: pattern.status === 'critical' ? '#fff3f3' : 
                                       pattern.status === 'warning' ? '#fff8e1' :
                                       'transparent'
                      }}>
                        <td style={styles.td}>{pattern.pattern}</td>
                        <td style={styles.td}>{pattern.count}</td>
                        <td style={styles.td}>{Math.round(pattern.frequency * 100)}%</td>
                        <td style={styles.td}>
                          <span style={{ color: getStatusColor(pattern.status) }}>
                            {getStatusIcon(pattern.status)} {pattern.status}
                          </span>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {hookAnalysis.length === 0 && componentTree.length === 0 && 
             Object.keys(performanceMetrics).length === 0 && errorPatterns.length === 0 && (
              <div style={{...styles.card, textAlign: 'center', color: '#666'}}>
                <p>Aucune analyse effectu√©e. Cliquez sur "üî¨ Lancer l'analyse approfondie" pour commencer.</p>
              </div>
            )}
          </div>
        )}

        {/* Onglet Multi-Org Isolation */}
        {activeTab === 'multiorg' && (
          <div>
            <div style={{ marginBottom: '16px' }}>
              <button 
                onClick={runMultiOrgIsolationTest} 
                disabled={isTestingMultiOrg}
                style={styles.button}
              >
                {isTestingMultiOrg ? '‚è≥ Test en cours...' : 'üîí Lancer le test d\'isolation'}
              </button>
              <button 
                onClick={() => setMultiOrgTestResults(null)} 
                style={{...styles.button, marginLeft: '8px', backgroundColor: '#6c757d'}}
              >
                üßπ Clear
              </button>
            </div>

            {/* √âtat de l'organisation */}
            <div style={styles.card}>
              <h4 style={styles.cardTitle}>üè¢ Organisation Courante</h4>
              {currentOrganization ? (
                <>
                  <div style={styles.stat}>
                    <span style={styles.label}>Nom:</span>
                    <span style={styles.value}>{currentOrganization.name}</span>
                  </div>
                  <div style={styles.stat}>
                    <span style={styles.label}>ID:</span>
                    <span style={styles.value}>{currentOrganization.id}</span>
                  </div>
                </>
              ) : (
                <div style={{ color: '#dc3545' }}>‚ùå Aucune organisation s√©lectionn√©e</div>
              )}
            </div>

            {/* R√©sultats du test */}
            {multiOrgTestResults && (
              <>
                {/* Score de s√©curit√© */}
                <div style={{
                  ...styles.card, 
                  marginTop: '16px',
                  backgroundColor: multiOrgTestResults.status === 'secure' ? '#d4edda' :
                                 multiOrgTestResults.status === 'warning' ? '#fff3cd' : '#f8d7da'
                }}>
                  <h4 style={styles.cardTitle}>
                    {multiOrgTestResults.status === 'secure' ? 'üõ°Ô∏è' :
                     multiOrgTestResults.status === 'warning' ? '‚ö†Ô∏è' : 'üö®'} 
                    Score de S√©curit√©
                  </h4>
                  <div style={{ fontSize: '48px', fontWeight: 'bold', textAlign: 'center', marginBottom: '16px' }}>
                    {multiOrgTestResults.securityScore || 0}%
                  </div>
                  <div style={styles.grid}>
                    <div style={styles.stat}>
                      <span style={styles.label}>Documents totaux:</span>
                      <span style={styles.value}>{multiOrgTestResults.summary?.totalDocuments || 0}</span>
                    </div>
                    <div style={styles.stat}>
                      <span style={styles.label}>Documents de l'org:</span>
                      <span style={styles.value}>{multiOrgTestResults.summary?.organizationDocuments || 0}</span>
                    </div>
                    <div style={styles.stat}>
                      <span style={styles.label}>Documents expos√©s:</span>
                      <span style={{...styles.value, color: multiOrgTestResults.summary?.leakedDocuments > 0 ? '#dc3545' : '#28a745'}}>
                        {multiOrgTestResults.summary?.leakedDocuments || 0}
                      </span>
                    </div>
                    <div style={styles.stat}>
                      <span style={styles.label}>Sans organizationId:</span>
                      <span style={{...styles.value, color: multiOrgTestResults.summary?.missingOrgIdDocuments > 0 ? '#ffc107' : '#28a745'}}>
                        {multiOrgTestResults.summary?.missingOrgIdDocuments || 0}
                      </span>
                    </div>
                  </div>
                </div>

                {/* R√©sultats par collection */}
                {multiOrgTestResults.tests && multiOrgTestResults.tests.length > 0 && (
                  <div style={{...styles.card, marginTop: '16px'}}>
                    <h4 style={styles.cardTitle}>üìä R√©sultats par Collection</h4>
                    <table style={styles.table}>
                      <thead>
                        <tr>
                          <th style={styles.th}>Collection</th>
                          <th style={styles.th}>Total</th>
                          <th style={styles.th}>Organisation</th>
                          <th style={styles.th}>Expos√©s</th>
                          <th style={styles.th}>Sans Org ID</th>
                          <th style={styles.th}>Statut</th>
                        </tr>
                      </thead>
                      <tbody>
                        {multiOrgTestResults.tests.map((test, index) => (
                          <tr key={index} style={{
                            backgroundColor: test.status === 'error' ? '#fff3f3' :
                                           test.status === 'warning' ? '#fff8e1' :
                                           test.status === 'success' ? '#f3fff3' : 'transparent'
                          }}>
                            <td style={styles.td}>{test.collection}</td>
                            <td style={styles.td}>{test.totalDocuments || '-'}</td>
                            <td style={styles.td}>{test.organizationDocuments || '-'}</td>
                            <td style={{...styles.td, color: test.leakedDocuments > 0 ? '#dc3545' : '#28a745'}}>
                              {test.leakedDocuments || 0}
                            </td>
                            <td style={{...styles.td, color: test.missingOrgId > 0 ? '#ffc107' : '#28a745'}}>
                              {test.missingOrgId || 0}
                            </td>
                            <td style={styles.td}>
                              {test.error ? (
                                <span style={{ color: '#dc3545' }}>‚ùå {test.error}</span>
                              ) : (
                                <span style={{ color: getStatusColor(test.status) }}>
                                  {getStatusIcon(test.status)}
                                </span>
                              )}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}

                {/* Probl√®mes d√©tect√©s */}
                {multiOrgTestResults.issues && multiOrgTestResults.issues.length > 0 && (
                  <div style={{...styles.card, marginTop: '16px', backgroundColor: '#fff3f3'}}>
                    <h4 style={styles.cardTitle}>üö® Probl√®mes D√©tect√©s</h4>
                    {multiOrgTestResults.issues.map((issue, index) => (
                      <div key={index} style={{
                        padding: '8px',
                        marginBottom: '8px',
                        borderRadius: '4px',
                        backgroundColor: issue.severity === 'critical' ? '#f8d7da' :
                                       issue.severity === 'high' ? '#fff3cd' :
                                       issue.severity === 'medium' ? '#cce5ff' : '#d1ecf1',
                        color: issue.severity === 'critical' ? '#721c24' :
                               issue.severity === 'high' ? '#856404' :
                               issue.severity === 'medium' ? '#004085' : '#0c5460'
                      }}>
                        <strong>{getStatusIcon(issue.type)} {issue.collection || 'G√©n√©ral'}:</strong> {issue.message}
                        {issue.organizations && (
                          <div style={{ fontSize: '12px', marginTop: '4px' }}>
                            Organisations: {issue.organizations.join(', ')}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}

                {/* Recommandations */}
                {multiOrgTestResults.status !== 'secure' && (
                  <div style={{...styles.card, marginTop: '16px', backgroundColor: '#d1ecf1'}}>
                    <h4 style={styles.cardTitle}>üí° Recommandations</h4>
                    <ul style={{ margin: 0, paddingLeft: '20px' }}>
                      {multiOrgTestResults.summary?.leakedDocuments > 0 && (
                        <li>V√©rifier que tous les hooks filtrent correctement par organizationId</li>
                      )}
                      {multiOrgTestResults.summary?.missingOrgIdDocuments > 0 && (
                        <li>Migrer les documents sans organizationId vers l'organisation appropri√©e</li>
                      )}
                      <li>Tester r√©guli√®rement l'isolation des donn√©es</li>
                      <li>Former l'√©quipe sur les bonnes pratiques multi-organisation</li>
                    </ul>
                  </div>
                )}
              </>
            )}

            {!multiOrgTestResults && !isTestingMultiOrg && (
              <div style={{...styles.card, marginTop: '16px', textAlign: 'center', color: '#666'}}>
                <p>Cliquez sur "üîí Lancer le test d'isolation" pour v√©rifier la s√©curit√© multi-organisation.</p>
                <p style={{ fontSize: '12px', marginTop: '8px' }}>
                  Ce test v√©rifie que chaque utilisateur ne peut acc√©der qu'aux donn√©es de son organisation.
                </p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default UnifiedDebugDashboard; 