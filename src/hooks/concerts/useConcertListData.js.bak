import { useState, useEffect, useCallback, useRef } from 'react';
import { 
  collection, 
  query, 
  orderBy, 
  getDocs, 
  doc, 
  getDoc, 
  limit, 
  startAfter,
  where, 
  db 
} from '@/firebaseInit';

/**
 * Hook to fetch concerts, form data, and contracts
 * Version optimis√©e avec pagination pour am√©liorer les performances
 */
export const useConcertListData = () => {
  const [concerts, setConcerts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState(null);
  const [concertsWithForms, setConcertsWithForms] = useState([]);
  const [unvalidatedForms, setUnvalidatedForms] = useState([]);
  const [concertsWithContracts, setConcertsWithContracts] = useState({});
  const [lastUpdate, setLastUpdate] = useState(Date.now());
  const [hasMore, setHasMore] = useState(true);
  
  // R√©f√©rence au dernier document pour la pagination
  const lastVisibleRef = useRef(null);
  const pageSize = 10; // Nombre d'√©l√©ments par page

  const lastFetchRef = useRef(0);
  const isInitialRenderRef = useRef(true);
  const cacheRef = useRef({
    concerts: {},
    lieux: {},
    programmateurs: {}
  });

  const minTimeBetweenFetches = 10000; // 10 secondes minimum entre deux fetch

  const fetchConcertsAndForms = useCallback(async (loadMore = false) => {
    // √âviter les rechargements trop fr√©quents sauf pour le chargement de plus d'√©l√©ments
    const now = Date.now();
    if (!loadMore && now - lastFetchRef.current < minTimeBetweenFetches) {
      console.log('Ignorer le rechargement - trop r√©cent');
      return;
    }
    
    lastFetchRef.current = now;
    
    try {
      if (loadMore) {
        setLoadingMore(true);
      } else {
        setLoading(true);
        // R√©initialiser l'√©tat de pagination lors d'un chargement complet
        lastVisibleRef.current = null;
        setHasMore(true);
      }
      
      console.log(`Chargement des donn√©es des concerts... (${loadMore ? 'page suivante' : 'premi√®re page'})`);
      
      // R√©cup√©rer les concerts avec seulement les champs n√©cessaires
      const concertsRef = collection(db, 'concerts');
      let q = query(concertsRef, orderBy('date', 'desc'), limit(pageSize));
      
      // Ajouter la pagination si n√©cessaire
      if (loadMore && lastVisibleRef.current) {
        q = query(concertsRef, orderBy('date', 'desc'), startAfter(lastVisibleRef.current), limit(pageSize));
      } else if (loadMore && !lastVisibleRef.current) {
        console.log('Impossible de charger plus - pas de r√©f√©rence au dernier document');
        setLoadingMore(false);
        return;
      }
      
      const querySnapshot = await getDocs(q);

      // Mise √† jour de la r√©f√©rence au dernier document pour la pagination suivante
      const lastDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
      lastVisibleRef.current = lastDoc || null;
      
      // Si aucun concert n'est retourn√© ou moins que la taille de page, il n'y a plus de donn√©es √† charger
      if (querySnapshot.docs.length === 0 || querySnapshot.docs.length < pageSize) {
        setHasMore(false);
      }

      const concertsData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      
      // Mettre √† jour la r√©f√©rence du dernier document visible
      lastVisibleRef.current = querySnapshot.docs[querySnapshot.docs.length - 1];
      
      // Collecter les IDs uniques pour les lieux et programmateurs
      const lieuxIds = [...new Set(concertsData.filter(c => c.lieuId).map(c => c.lieuId))];
      const programmateurIds = [...new Set(concertsData.filter(c => c.programmateurId).map(c => c.programmateurId))];
      
      // Charger les lieux et programmateurs en batch (en parall√®le)
      const [lieuxData, programmateursData] = await Promise.all([
        fetchEntitiesBatch('lieux', lieuxIds, ['id', 'nom', 'ville', 'capacite']),
        fetchEntitiesBatch('programmateurs', programmateurIds, ['id', 'nom', 'prenom', 'email'])
      ]);
      
      // Mise en cache des lieux et programmateurs
      lieuxData.forEach(lieu => {
        if (lieu) cacheRef.current.lieux[lieu.id] = lieu;
      });
      
      programmateursData.forEach(prog => {
        if (prog) cacheRef.current.programmateurs[prog.id] = prog;
      });
      
      // Enrichir chaque concert avec les donn√©es de lieu et programmateur
      const enrichedConcerts = concertsData.map(concert => {
        const enriched = { ...concert };
        
        // Ajouter les donn√©es du lieu s'il existe
        if (concert.lieuId && cacheRef.current.lieux[concert.lieuId]) {
          enriched.lieu = cacheRef.current.lieux[concert.lieuId];
        }
        
        // Ajouter les donn√©es du programmateur s'il existe
        if (concert.programmateurId && cacheRef.current.programmateurs[concert.programmateurId]) {
          enriched.programmateur = cacheRef.current.programmateurs[concert.programmateurId];
        }
        
        return enriched;
      });
      
      setConcerts(prevConcerts => loadMore ? [...prevConcerts, ...enrichedConcerts] : enrichedConcerts);
      
      // N'effectuer les requ√™tes pour les formulaires et contrats que si on a des concerts
      // Nous enregistrons √©galement le temps de d√©but pour mesurer la performance
      if (concertsData.length > 0) {
        try {
          const startTime = performance.now();
          console.log('üì• Chargement des formulaires et contrats pour les concerts sp√©cifiques...');
          
          // Obtenir la liste des IDs de concerts
          const concertIds = concertsData.map(concert => concert.id);
          
          // 1. R√©cup√©ration des formulaires UNIQUEMENT pour les concerts actuels
          const formsRef = collection(db, 'formulaires');
          const formsQuery = query(formsRef, where('concertId', 'in', concertIds));
          const formsSnapshot = await getDocs(formsQuery);
          
          const formsData = formsSnapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          
          // Identifier les concerts avec formulaires
          const concertsWithFormsIds = [];
          const unvalidatedFormsIds = [];
          
          formsData.forEach(form => {
            if (form.concertId) {
              concertsWithFormsIds.push(form.concertId);
              
              // Si le formulaire n'est pas valid√©
              if (form.statut === 'en_attente' || form.statut === 'non_valide') {
                unvalidatedFormsIds.push(form.concertId);
              }
            }
          });
          
          setConcertsWithForms(concertsWithFormsIds);
          setUnvalidatedForms(unvalidatedFormsIds);
          
          // 2. R√©cup√©ration des contrats UNIQUEMENT pour les concerts actuels
          const contractsRef = collection(db, 'contrats');
          const contractsQuery = query(contractsRef, where('concertId', 'in', concertIds));
          const contractsSnapshot = await getDocs(contractsQuery);
          
          const contractsMap = {};
          
          contractsSnapshot.docs.forEach(doc => {
            const contract = { id: doc.id, ...doc.data() };
            if (contract.concertId) {
              contractsMap[contract.concertId] = contract;
            }
          });
          
          setConcertsWithContracts(contractsMap);
          
          // Log de performance pour le chargement des formulaires et contrats
          const endTime = performance.now();
          console.log(`üïí Requ√™te formulaires et contrats: ${(endTime - startTime).toFixed(2)}ms`);
          
        } catch (err) {
          console.error('Erreur lors du chargement des formulaires et contrats:', err);
          // Ne pas bloquer le chargement des concerts en cas d'erreur sur les formulaires/contrats
        }
      } else {
        // Pas de concerts, donc pas de formulaires ni de contrats
        setConcertsWithForms([]);
        setUnvalidatedForms([]);
        setConcertsWithContracts({});
      }
      
      // Mettre √† jour la derni√®re date de mise √† jour
      setLastUpdate(Date.now());
    } catch (err) {
      console.error('Erreur lors du chargement des donn√©es des concerts:', err);
      setError(err.message);
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, []);
  
  // Fonction utilitaire pour r√©cup√©rer des entit√©s par lot - IMPL√âMENTATION OPTIMIS√âE
  const fetchEntitiesBatch = async (collectionName, ids, fields) => {
    if (!ids || ids.length === 0) return [];
    
    // Filtrer les IDs d√©j√† en cache
    const cachedEntities = [];
    const idsToFetch = [];
    
    ids.forEach(id => {
      if (cacheRef.current[collectionName][id]) {
        cachedEntities.push(cacheRef.current[collectionName][id]);
      } else {
        idsToFetch.push(id);
      }
    });
    
    // Si tous les √©l√©ments sont en cache, retourner directement
    if (idsToFetch.length === 0) {
      return cachedEntities;
    }
    
    // Mesure de performance
    const startTime = performance.now();
    
    try {
      // Firestore limite les requ√™tes 'in' √† 10 √©l√©ments max
      const batchSize = 10;
      const batchResults = [];
      
      // Traiter les IDs par lots de 10
      for (let i = 0; i < idsToFetch.length; i += batchSize) {
        const batchIds = idsToFetch.slice(i, i + batchSize);
        
        // Utiliser "__name__" comme identifiant de document pour where...in
        const batchQuery = query(
          collection(db, collectionName),
          where('__name__', 'in', batchIds)
        );
        
        const querySnapshot = await getDocs(batchQuery);
        
        // Traiter les r√©sultats du lot
        const results = querySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        
        // Mettre en cache pour les futures utilisations
        results.forEach(item => {
          if (item && item.id) {
            cacheRef.current[collectionName][item.id] = item;
          }
        });
        
        batchResults.push(...results);
      }
      
      // Log de performance
      const endTime = performance.now();
      console.log(`üïí Requ√™te batch ${collectionName} (${idsToFetch.length} items): ${(endTime - startTime).toFixed(2)}ms`);
      
      return [...cachedEntities, ...batchResults];
    } catch (error) {
      console.error(`[Debug] Erreur g√©n√©rale lors du chargement des ${collectionName}:`, error);
      
      // En cas d'erreur avec la m√©thode batch, on revient √† la m√©thode document par document
      // mais sans les logs verbeux pour am√©liorer les performances
      const results = [];
      for (const id of idsToFetch) {
        try {
          const docSnap = await getDoc(doc(db, collectionName, id));
          if (docSnap.exists()) {
            const data = { id: docSnap.id, ...docSnap.data() };
            results.push(data);
            cacheRef.current[collectionName][id] = data;
          }
        } catch (e) {
          // Silencieux pour √©viter de remplir la console d'erreurs
        }
      }
      
      return [...cachedEntities, ...results];
    }
  };

  // Effet initial pour charger les donn√©es
  useEffect(() => {
    if (isInitialRenderRef.current) {
      isInitialRenderRef.current = false;
      fetchConcertsAndForms();
    }
  }, [fetchConcertsAndForms]);

  // Fonction pour v√©rifier si un concert a un formulaire associ√©
  const hasForm = useCallback((concertId) => {
    return concertsWithForms.includes(concertId) || 
           concerts.find(c => c.id === concertId)?.formId !== undefined;
  }, [concerts, concertsWithForms]);

  // Fonction pour v√©rifier si un concert a un formulaire non valid√©
  const hasUnvalidatedForm = useCallback((concertId) => {
    return unvalidatedForms.includes(concertId);
  }, [unvalidatedForms]);

  // Fonction pour v√©rifier si un concert a un contrat associ√©
  const hasContract = useCallback((concertId) => {
    return concertsWithContracts[concertId] !== undefined;
  }, [concertsWithContracts]);

  // Fonction pour obtenir le statut d'un contrat
  const getContractStatus = useCallback((concertId) => {
    const contract = concertsWithContracts[concertId];
    return contract ? contract.status : null;
  }, [concertsWithContracts]);

  return {
    concerts,
    loading,
    loadingMore,
    error,
    concertsWithForms,
    unvalidatedForms,
    concertsWithContracts,
    lastUpdate,
    hasMore,
    loadMore: () => {
      if (!loading && !loadingMore && hasMore) {
        fetchConcertsAndForms(true);
      }
    },
    refreshData: () => fetchConcertsAndForms(false),
    hasForm,
    hasUnvalidatedForm,
    hasContract,
    getContractStatus
  };
};

// Ajout de l'export par d√©faut pour la compatibilit√© avec index.js
export default useConcertListData;