#!/usr/bin/env node

/**
 * Script de Migration : contactId ‚Üí contactIds
 * 
 * Convertit tous les concerts ayant un contactId vers le nouveau syst√®me contactIds (array)
 * Maintient la compatibilit√© et les relations bidirectionnelles
 * 
 * Usage:
 *   node scripts/migrate-contact-to-contacts.js [--dry-run] [--verbose]
 * 
 * Options:
 *   --dry-run   Simulation sans modification des donn√©es
 *   --verbose   Affichage d√©taill√© des op√©rations
 * 
 * Cr√©√© le : Janvier 2025
 * Dans le cadre de l'unification du syst√®me de contacts
 */

const { initializeApp } = require('firebase/app');
const { 
  getFirestore, 
  collection, 
  query, 
  where, 
  getDocs, 
  doc, 
  updateDoc, 
  getDoc,
  serverTimestamp,
  writeBatch 
} = require('firebase/firestore');

// Configuration Firebase (√† adapter selon votre environnement)
const firebaseConfig = {
  // Configuration sera charg√©e depuis l'environnement
  projectId: process.env.VITE_FIREBASE_PROJECT_ID || 'tourcraft-dev',
  // Autres configurations selon besoin
};

// Initialisation
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Variables de configuration
const DRY_RUN = process.argv.includes('--dry-run');
const VERBOSE = process.argv.includes('--verbose') || DRY_RUN;
const BATCH_SIZE = 50; // Traiter par lots pour √©viter les timeouts

// Statistiques de migration
const stats = {
  totalConcerts: 0,
  concertsToMigrate: 0,
  concertsMigrated: 0,
  concertsSkipped: 0,
  errors: [],
  bidirectionalUpdates: 0
};

/**
 * Fonction principale de migration
 */
async function migrateConcertContacts() {
  console.log('üöÄ Migration contactId ‚Üí contactIds');
  console.log('=====================================');
  console.log(`Mode: ${DRY_RUN ? 'üß™ DRY-RUN (simulation)' : '‚ö° LIVE'}`);
  console.log(`Verbeux: ${VERBOSE ? 'Oui' : 'Non'}`);
  console.log('');

  try {
    // Phase 1: Analyse des donn√©es existantes
    await analyzeExistingData();

    // Phase 2: Migration des concerts
    if (stats.concertsToMigrate > 0) {
      await migrateConcerts();
    } else {
      console.log('‚úÖ Aucun concert √† migrer trouv√©');
    }

    // Phase 3: V√©rification post-migration
    if (!DRY_RUN && stats.concertsMigrated > 0) {
      await verifyMigration();
    }

    // Rapport final
    printFinalReport();

  } catch (error) {
    console.error('‚ùå Erreur fatale during migration:', error);
    process.exit(1);
  }
}

/**
 * Analyse les donn√©es existantes pour identifier les concerts √† migrer
 */
async function analyzeExistingData() {
  console.log('üîç Phase 1: Analyse des donn√©es existantes...');

  try {
    // Compter tous les concerts
    const allConcertsSnapshot = await getDocs(collection(db, 'concerts'));
    stats.totalConcerts = allConcertsSnapshot.size;

    // Identifier les concerts avec contactId mais sans contactIds
    const concertsToMigrate = [];
    
    allConcertsSnapshot.forEach(doc => {
      const data = doc.data();
      const hasContactId = data.contactId && typeof data.contactId === 'string';
      const hasContactIds = data.contactIds && Array.isArray(data.contactIds) && data.contactIds.length > 0;

      if (hasContactId && !hasContactIds) {
        concertsToMigrate.push({
          id: doc.id,
          contactId: data.contactId,
          nom: data.nom || 'Concert sans nom',
          date: data.date || 'Date inconnue'
        });
      }
    });

    stats.concertsToMigrate = concertsToMigrate.length;

    console.log(`   üìä Concerts totaux: ${stats.totalConcerts}`);
    console.log(`   üéØ Concerts √† migrer: ${stats.concertsToMigrate}`);

    if (VERBOSE && concertsToMigrate.length > 0) {
      console.log('\n   üìã Liste des concerts √† migrer:');
      concertsToMigrate.forEach((concert, index) => {
        console.log(`      ${index + 1}. ${concert.nom} (${concert.id}) ‚Üí contact: ${concert.contactId}`);
      });
    }

    return concertsToMigrate;

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'analyse:', error);
    throw error;
  }
}

/**
 * Migre les concerts par lots
 */
async function migrateConcerts() {
  console.log('\nüîÑ Phase 2: Migration des concerts...');

  try {
    // R√©cup√©rer la liste des concerts √† migrer
    const concertsQuery = query(
      collection(db, 'concerts'),
      where('contactId', '!=', null)
    );
    const concertsSnapshot = await getDocs(concertsQuery);

    const batches = [];
    let currentBatch = [];

    // Traitement par lots
    for (const docSnapshot of concertsSnapshot.docs) {
      const concertData = docSnapshot.data();
      
      // V√©rifier si migration n√©cessaire
      if (concertData.contactId && (!concertData.contactIds || concertData.contactIds.length === 0)) {
        currentBatch.push({
          id: docSnapshot.id,
          data: concertData
        });

        if (currentBatch.length >= BATCH_SIZE) {
          batches.push([...currentBatch]);
          currentBatch = [];
        }
      }
    }

    // Ajouter le dernier lot s'il n'est pas vide
    if (currentBatch.length > 0) {
      batches.push(currentBatch);
    }

    // Migrer chaque lot
    for (let i = 0; i < batches.length; i++) {
      await migrateBatch(batches[i], i + 1, batches.length);
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de la migration:', error);
    throw error;
  }
}

/**
 * Migre un lot de concerts
 */
async function migrateBatch(batch, batchNumber, totalBatches) {
  console.log(`   üì¶ Lot ${batchNumber}/${totalBatches} (${batch.length} concerts)`);

  if (DRY_RUN) {
    // Simulation
    for (const concert of batch) {
      console.log(`      üß™ [DRY-RUN] Concert ${concert.data.nom} : contactId=${concert.data.contactId} ‚Üí contactIds=[${concert.data.contactId}]`);
      stats.concertsMigrated++;
    }
    return;
  }

  // Migration r√©elle avec batch Firestore
  const firestoreBatch = writeBatch(db);

  for (const concert of batch) {
    try {
      const concertRef = doc(db, 'concerts', concert.id);
      
      // Pr√©parer les nouvelles donn√©es
      const updateData = {
        contactIds: [concert.data.contactId],
        updatedAt: serverTimestamp(),
        // Garder contactId temporairement pour compatibilit√©
        contactId_migrated: concert.data.contactId
      };

      // Supprimer l'ancien contactId
      updateData.contactId = null;

      firestoreBatch.update(concertRef, updateData);

      if (VERBOSE) {
        console.log(`      ‚úÖ Concert ${concert.data.nom} pr√©par√© pour migration`);
      }

      stats.concertsMigrated++;

    } catch (error) {
      console.error(`      ‚ùå Erreur concert ${concert.id}:`, error);
      stats.errors.push({
        concertId: concert.id,
        error: error.message
      });
    }
  }

  // Ex√©cuter le batch
  try {
    await firestoreBatch.commit();
    console.log(`      ‚úÖ Lot ${batchNumber} migr√© avec succ√®s`);

    // Mettre √† jour les relations bidirectionnelles
    for (const concert of batch) {
      await updateBidirectionalRelation(concert.id, concert.data.contactId);
    }

  } catch (error) {
    console.error(`      ‚ùå Erreur lors du commit du lot ${batchNumber}:`, error);
    throw error;
  }
}

/**
 * Met √† jour la relation bidirectionnelle dans le contact
 */
async function updateBidirectionalRelation(concertId, contactId) {
  try {
    const contactRef = doc(db, 'contacts', contactId);
    const contactDoc = await getDoc(contactRef);

    if (!contactDoc.exists()) {
      if (VERBOSE) {
        console.log(`      ‚ö†Ô∏è  Contact ${contactId} non trouv√© pour concert ${concertId}`);
      }
      return;
    }

    const contactData = contactDoc.data();
    let concertsIds = contactData.concertsIds || [];

    // Ajouter l'ID du concert s'il n'est pas d√©j√† pr√©sent
    if (!concertsIds.includes(concertId)) {
      concertsIds.push(concertId);

      if (!DRY_RUN) {
        await updateDoc(contactRef, {
          concertsIds: concertsIds,
          updatedAt: serverTimestamp()
        });
      }

      stats.bidirectionalUpdates++;

      if (VERBOSE) {
        console.log(`      üîó Relation bidirectionnelle mise √† jour: contact ${contactId} ‚Üî concert ${concertId}`);
      }
    }

  } catch (error) {
    console.error(`      ‚ùå Erreur relation bidirectionnelle ${contactId} ‚Üî ${concertId}:`, error);
    stats.errors.push({
      type: 'bidirectional',
      concertId,
      contactId,
      error: error.message
    });
  }
}

/**
 * V√©rifie que la migration s'est bien pass√©e
 */
async function verifyMigration() {
  console.log('\nüîç Phase 3: V√©rification post-migration...');

  try {
    // Compter les concerts avec contactIds
    const concertsWithContactIds = query(
      collection(db, 'concerts'),
      where('contactIds', '!=', null)
    );
    const verifySnapshot = await getDocs(concertsWithContactIds);

    let migratedCount = 0;
    let stillHaveContactId = 0;

    verifySnapshot.forEach(doc => {
      const data = doc.data();
      if (data.contactIds && Array.isArray(data.contactIds) && data.contactIds.length > 0) {
        migratedCount++;
      }
      if (data.contactId) {
        stillHaveContactId++;
      }
    });

    console.log(`   ‚úÖ Concerts avec contactIds: ${migratedCount}`);
    console.log(`   ‚ö†Ô∏è  Concerts avec encore contactId: ${stillHaveContactId}`);

    if (stillHaveContactId > 0) {
      console.log('   ‚ÑπÔ∏è  Note: contactId peut √™tre gard√© temporairement pour compatibilit√©');
    }

  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification:', error);
  }
}

/**
 * Affiche le rapport final
 */
function printFinalReport() {
  console.log('\nüìã RAPPORT FINAL DE MIGRATION');
  console.log('===============================');
  console.log(`Mode d'ex√©cution: ${DRY_RUN ? 'DRY-RUN (simulation)' : 'LIVE'}`);
  console.log(`Concerts totaux: ${stats.totalConcerts}`);
  console.log(`Concerts √† migrer: ${stats.concertsToMigrate}`);
  console.log(`Concerts migr√©s: ${stats.concertsMigrated}`);
  console.log(`Relations bidirectionnelles mises √† jour: ${stats.bidirectionalUpdates}`);
  console.log(`Erreurs: ${stats.errors.length}`);

  if (stats.errors.length > 0) {
    console.log('\n‚ùå ERREURS RENCONTR√âES:');
    stats.errors.forEach((error, index) => {
      console.log(`   ${index + 1}. ${error.concertId || error.type}: ${error.error}`);
    });
  }

  if (DRY_RUN) {
    console.log('\nüß™ Ceci √©tait une simulation. Relancez sans --dry-run pour appliquer les changements.');
  } else if (stats.concertsMigrated > 0) {
    console.log('\n‚úÖ Migration termin√©e avec succ√®s !');
    console.log('   Les concerts utilisent maintenant le syst√®me contactIds unifi√©.');
  }

  console.log('');
}

/**
 * Point d'entr√©e
 */
if (require.main === module) {
  migrateConcertContacts()
    .then(() => {
      console.log('üéâ Script termin√©');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = {
  migrateConcertContacts,
  analyzeExistingData
};