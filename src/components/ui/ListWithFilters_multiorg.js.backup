import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import {  collection, getDocs, query, where, orderBy, limit, startAfter  } from '@/services/firebase-service';
import { db } from '../../services/firebase-service';
import { useResponsive } from '@/hooks/common';
import { useOrganization } from '@/context/OrganizationContext';
import StatsCards from './StatsCards';
import styles from './ListWithFilters.module.css';

/**
 * Composant g√©n√©rique pour afficher des listes avec filtres, tri et pagination
 * 
 * @param {Object} props - Propri√©t√©s du composant
 * @param {string} props.entityType - Type d'entit√© (artistes, programmateurs, etc.)
 * @param {string} props.title - Titre de la liste
 * @param {Array} props.columns - Configuration des colonnes [{id, label, field, sortable, width, render}]
 * @param {Object} props.filters - Filtres initiaux {field: value, ...}
 * @param {Object} props.sort - Tri initial {field, direction}
 * @param {React.ReactNode} props.actions - Actions personnalis√©es √† afficher en haut
 * @param {Function} props.onRowClick - Fonction appel√©e lors du clic sur une ligne
 * @param {number} props.pageSize - Nombre d'√©l√©ments par page (d√©faut: 10)
 * @param {boolean} props.showRefresh - Afficher le bouton de rafra√Æchissement
 * @param {Array} props.filterOptions - Options de filtres 
 *    [{id, label, field, type, options, placeholder}]
 * @param {Function} props.renderActions - Fonction pour rendre les actions par ligne
 * @param {Function} props.calculateStats - Fonction pour calculer les statistiques
 * @param {boolean} props.showStats - Afficher les cartes de statistiques
 * @param {boolean} props.showAdvancedFilters - Activer les filtres avanc√©s
 * @param {Array} props.advancedFilterOptions - Options de filtres avanc√©s
 * @return {JSX.Element} Composant de liste avec filtres
 */
const ListWithFilters = ({
  entityType,
  title,
  columns,
  filters: initialFilters = {},
  sort: initialSort = { field: 'createdAt', direction: 'desc' },
  actions,
  onRowClick,
  pageSize = 10,
  showRefresh = true,
  filterOptions = [],
  renderActions,
  calculateStats,
  showStats = false,
  showAdvancedFilters = false,
  advancedFilterOptions = [],
}) => {
  const { isMobile } = useResponsive();
  const { currentOrg } = useOrganization();
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState(initialFilters);
  const [sort, setSort] = useState(initialSort);
  const [lastDoc, setLastDoc] = useState(null);
  const [hasMore, setHasMore] = useState(false);
  const [filterValues, setFilterValues] = useState({});
  const [showMobileFilters, setShowMobileFilters] = useState(false);
  const [showAdvancedFiltersPanel, setShowAdvancedFiltersPanel] = useState(false);
  const [advancedFilterValues, setAdvancedFilterValues] = useState({});

  // Configuration des filtres
  useEffect(() => {
    const initialValues = {};
    filterOptions.forEach(filter => {
      if (filters[filter.field] !== undefined) {
        initialValues[filter.id] = filters[filter.field];
      } else {
        initialValues[filter.id] = '';
      }
    });
    setFilterValues(initialValues);
  }, [filterOptions, filters]);

  // Chargement des donn√©es
  const loadData = async (isLoadMore = false) => {
    setLoading(true);
    
    try {
      let loadedItems = [];
      let lastVisible = null;
      let hasMoreItems = false;

      // Gestion du contexte organisationnel avec fallback
      if (currentOrg) {
        // 1. Tentative avec collection organisationnelle
        const orgCollectionName = `${entityType}_org_${currentOrg.id}`;
        console.log(`üìÅ Tentative collection organisationnelle: ${orgCollectionName}`);
        
        try {
          const orgCollectionRef = collection(db, orgCollectionName);
          let orgQuery = orgCollectionRef;
          
          // Ajout des filtres
          const filterEntries = Object.entries(filters);
          if (filterEntries.length > 0) {
            const filterConditions = filterEntries
              .filter(([field, value]) => value !== undefined && value !== '')
              .map(([field, value]) => where(field, '==', value));
            
            if (filterConditions.length > 0) {
              orgQuery = query(orgQuery, ...filterConditions);
            }
          }
          
          // Tri
          orgQuery = query(orgQuery, orderBy(sort.field, sort.direction));
          
          // Pagination
          if (isLoadMore && lastDoc) {
            orgQuery = query(orgQuery, startAfter(lastDoc), limit(pageSize));
          } else {
            orgQuery = query(orgQuery, limit(pageSize));
          }
          
          const orgQuerySnapshot = await getDocs(orgQuery);
          
          if (orgQuerySnapshot.docs.length > 0) {
            console.log(`‚úÖ Donn√©es trouv√©es dans collection organisationnelle: ${orgQuerySnapshot.docs.length} √©l√©ments`);
            lastVisible = orgQuerySnapshot.docs[orgQuerySnapshot.docs.length - 1];
            hasMoreItems = orgQuerySnapshot.docs.length === pageSize;
            
            loadedItems = orgQuerySnapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
              _source: 'organizational' // Marquer la source
            }));
          } else {
            console.log(`‚ö†Ô∏è Collection organisationnelle vide, fallback vers collection standard`);
            throw new Error('Collection organisationnelle vide');
          }
        } catch (orgError) {
          console.log(`üîÑ Fallback vers collection standard: ${entityType}`);
          
          // 2. Fallback vers collection standard avec filtre organizationId
          const standardCollectionRef = collection(db, entityType);
          let fallbackQuery = standardCollectionRef;
          
          // Filtrer par organizationId si les donn√©es sont d√©j√† multi-org
          const orgFilters = [
            ...Object.entries(filters),
            ['organizationId', currentOrg.id] // Ajouter le filtre org
          ];
          
          const filterConditions = orgFilters
            .filter(([field, value]) => value !== undefined && value !== '')
            .map(([field, value]) => where(field, '==', value));
          
          if (filterConditions.length > 0) {
            fallbackQuery = query(fallbackQuery, ...filterConditions);
          }
          
          // Tri
          fallbackQuery = query(fallbackQuery, orderBy(sort.field, sort.direction));
          
          // Pagination
          if (isLoadMore && lastDoc) {
            fallbackQuery = query(fallbackQuery, startAfter(lastDoc), limit(pageSize));
          } else {
            fallbackQuery = query(fallbackQuery, limit(pageSize));
          }
          
          const fallbackSnapshot = await getDocs(fallbackQuery);
          
          if (fallbackSnapshot.docs.length > 0) {
            console.log(`‚úÖ Donn√©es trouv√©es dans collection standard avec filtre org: ${fallbackSnapshot.docs.length} √©l√©ments`);
            lastVisible = fallbackSnapshot.docs[fallbackSnapshot.docs.length - 1];
            hasMoreItems = fallbackSnapshot.docs.length === pageSize;
            
            loadedItems = fallbackSnapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
              _source: 'standard-filtered' // Marquer la source
            }));
          } else {
            console.log(`üîÑ Fallback final vers toutes les donn√©es standard`);
            
            // 3. Fallback final vers toutes les donn√©es standard (compatibilit√© legacy)
            let legacyQuery = standardCollectionRef;
            
            // Appliquer seulement les filtres utilisateur (pas organizationId)
            const userFilters = Object.entries(filters);
            if (userFilters.length > 0) {
              const filterConditions = userFilters
                .filter(([field, value]) => value !== undefined && value !== '')
                .map(([field, value]) => where(field, '==', value));
              
              if (filterConditions.length > 0) {
                legacyQuery = query(legacyQuery, ...filterConditions);
              }
            }
            
            // Tri
            legacyQuery = query(legacyQuery, orderBy(sort.field, sort.direction));
            
            // Pagination
            if (isLoadMore && lastDoc) {
              legacyQuery = query(legacyQuery, startAfter(lastDoc), limit(pageSize));
            } else {
              legacyQuery = query(legacyQuery, limit(pageSize));
            }
            
            const legacySnapshot = await getDocs(legacyQuery);
            
            console.log(`üìä Donn√©es legacy trouv√©es: ${legacySnapshot.docs.length} √©l√©ments`);
            lastVisible = legacySnapshot.docs[legacySnapshot.docs.length - 1];
            hasMoreItems = legacySnapshot.docs.length === pageSize;
            
            loadedItems = legacySnapshot.docs.map(doc => ({
              id: doc.id,
              ...doc.data(),
              _source: 'legacy' // Marquer la source
            }));
          }
        }
      } else {
        // Pas d'organisation : utiliser collection standard
        console.log(`üìÅ Utilisation de la collection globale: ${entityType}`);
        const collectionRef = collection(db, entityType);
        let q = collectionRef;
        
        // Ajout des filtres
        const filterEntries = Object.entries(filters);
        if (filterEntries.length > 0) {
          const filterConditions = filterEntries
            .filter(([field, value]) => value !== undefined && value !== '')
            .map(([field, value]) => where(field, '==', value));
          
          if (filterConditions.length > 0) {
            q = query(q, ...filterConditions);
          }
        }
        
        // Tri
        q = query(q, orderBy(sort.field, sort.direction));
        
        // Pagination
        if (isLoadMore && lastDoc) {
          q = query(q, startAfter(lastDoc), limit(pageSize));
        } else {
          q = query(q, limit(pageSize));
        }
        
        const querySnapshot = await getDocs(q);
        lastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];
        hasMoreItems = querySnapshot.docs.length === pageSize;
        
        loadedItems = querySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          _source: 'global' // Marquer la source
        }));
      }
      
      // Gestion de la pagination
      setLastDoc(lastVisible);
      setHasMore(hasMoreItems);
      
      // Mise √† jour des items
      if (isLoadMore) {
        setItems(prev => [...prev, ...loadedItems]);
      } else {
        setItems(loadedItems);
      }
      
      // Log du r√©sultat final
      if (loadedItems.length > 0) {
        const sourceInfo = loadedItems[0]?._source || 'unknown';
        console.log(`üìà Chargement r√©ussi: ${loadedItems.length} ${entityType} (source: ${sourceInfo})`);
      }
      
    } catch (error) {
      console.error(`‚ùå Erreur lors du chargement des ${entityType}:`, error);
      setItems([]);
    } finally {
      setLoading(false);
    }
  };

  // Chargement initial
  useEffect(() => {
    if (currentOrg) {
      loadData();
    } else {
      console.log('‚ö†Ô∏è Pas d\'organisation s√©lectionn√©e, chargement suspendu');
      setItems([]);
      setLoading(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entityType, filters, sort, pageSize, currentOrg]);

  // Changement de tri
  const handleSort = (field) => {
    if (sort.field === field) {
      // Inversion du tri sur la m√™me colonne
      setSort({
        field,
        direction: sort.direction === 'asc' ? 'desc' : 'asc',
      });
    } else {
      // Nouvelle colonne, tri par d√©faut
      setSort({
        field,
        direction: 'asc',
      });
    }
  };

  // Application des filtres
  const handleFilterApply = () => {
    const appliedFilters = {};
    
    // Transformation des valeurs de filtres en filtres appliqu√©s
    Object.entries(filterValues).forEach(([filterId, value]) => {
      const filterOption = filterOptions.find(opt => opt.id === filterId);
      
      if (filterOption && value !== '') {
        appliedFilters[filterOption.field] = value;
      }
    });
    
    setFilters(appliedFilters);
    setLastDoc(null); // R√©initialisation de la pagination
  };

  // R√©initialisation des filtres
  const handleFilterReset = () => {
    setFilterValues({});
    setFilters({});
    setLastDoc(null);
  };

  // Chargement de plus d'√©l√©ments
  const handleLoadMore = () => {
    loadData(true);
  };

  // Rafra√Æchissement des donn√©es
  const handleRefresh = () => {
    setLastDoc(null);
    loadData();
  };

  // Changement de valeur de filtre
  const handleFilterChange = (filterId, value) => {
    setFilterValues(prev => ({
      ...prev,
      [filterId]: value,
    }));
  };

  // Gestion des filtres avanc√©s
  const handleAdvancedFilterChange = (filterId, value) => {
    setAdvancedFilterValues(prev => ({
      ...prev,
      [filterId]: value,
    }));
  };

  const handleAdvancedFilterApply = () => {
    const newFilters = { ...filters };
    
    // Ajouter les filtres avanc√©s aux filtres existants
    Object.entries(advancedFilterValues).forEach(([filterId, value]) => {
      const filterOption = advancedFilterOptions.find(opt => opt.id === filterId);
      
      if (filterOption && value !== '') {
        newFilters[filterOption.field] = value;
      }
    });
    
    setFilters(newFilters);
    setLastDoc(null);
  };

  const handleAdvancedFilterReset = () => {
    setAdvancedFilterValues({});
    // Retirer les filtres avanc√©s des filtres appliqu√©s
    const newFilters = { ...filters };
    advancedFilterOptions.forEach(option => {
      delete newFilters[option.field];
    });
    setFilters(newFilters);
    setLastDoc(null);
  };

  // Gestion du clic sur une ligne
  const handleRowClick = (item) => {
    if (onRowClick) {
      onRowClick(item);
    }
  };

  // Rendu des colonnes
  const renderColumnValue = (item, column) => {
    if (column.render) {
      return column.render(item);
    }
    
    if (!column.field) {
      return '';
    }
    
    const value = column.field.split('.').reduce((obj, key) => 
      obj ? obj[key] : undefined, item);
      
    return value || '';
  };

  // D√©terminer si des filtres sont appliqu√©s
  const hasActiveFilters = Object.values(filters).some(value => 
    value !== undefined && value !== '');

  // Fonction pour rendre une carte mobile
  const renderMobileCard = (item) => {
    // Utiliser les 2-3 premi√®res colonnes pour l'affichage principal
    const mainColumns = columns.slice(0, 3);
    const titleColumn = columns[0];
    const titleValue = renderColumnValue(item, titleColumn);

    return (
      <div 
        key={item.id} 
        className={styles.mobileCard}
        onClick={() => handleRowClick(item)}
      >
        <div className={styles.mobileCardHeader}>
          <h3 className={styles.mobileCardTitle}>{titleValue}</h3>
          {renderActions && (
            <div 
              className={styles.mobileCardActions}
              onClick={(e) => e.stopPropagation()}
            >
              {renderActions(item)}
            </div>
          )}
        </div>
        
        <div className={styles.mobileCardContent}>
          {mainColumns.slice(1).map((column) => (
            <div key={column.id} className={styles.mobileCardField}>
              <div className={styles.mobileCardFieldLabel}>
                {column.label}
              </div>
              <div className={styles.mobileCardFieldValue}>
                {renderColumnValue(item, column)}
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  // Fonction pour d√©terminer le type de source des donn√©es
  const getDataSourceInfo = () => {
    if (items.length === 0) return null;
    
    const sourceType = items[0]?._source;
    switch (sourceType) {
      case 'organizational':
        return {
          type: 'success',
          icon: 'bi-building',
          message: 'Donn√©es organisationnelles charg√©es'
        };
      case 'standard-filtered':
        return {
          type: 'info',
          icon: 'bi-filter',
          message: 'Donn√©es standard filtr√©es par organisation'
        };
      case 'legacy':
        return {
          type: 'warning',
          icon: 'bi-database',
          message: 'Donn√©es legacy (toutes les donn√©es) - Migration recommand√©e'
        };
      case 'global':
        return {
          type: 'secondary',
          icon: 'bi-globe',
          message: 'Donn√©es globales (aucune organisation)'
        };
      default:
        return null;
    }
  };

  const dataSourceInfo = getDataSourceInfo();

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        {title && <h2 className={styles.title}>{title}</h2>}
        
        <div className={styles.actionsWrapper}>
          {actions}
          
          {showRefresh && (
            <button 
              className={styles.refreshButton} 
              onClick={handleRefresh}
              title="Rafra√Æchir"
            >
              <i className="bi bi-arrow-clockwise"></i>
            </button>
          )}
        </div>
      </div>
      
      {/* Banni√®re d'information sur la source des donn√©es */}
      {dataSourceInfo && items.length > 0 && (
        <div className={`${styles.dataSourceBanner} ${styles[dataSourceInfo.type]}`}>
          <i className={`bi ${dataSourceInfo.icon}`}></i>
          <span>{dataSourceInfo.message}</span>
          {dataSourceInfo.type === 'warning' && (
            <small style={{ marginLeft: '10px', opacity: 0.8 }}>
              ‚Ä¢ Contactez l'administrateur pour la migration multi-organisation
            </small>
          )}
        </div>
      )}
      
      {/* Stats cards */}
      {showStats && calculateStats && (
        <StatsCards stats={calculateStats(items)} />
      )}
      
      {filterOptions.length > 0 && (
        <>
          {isMobile && (
            <button
              className={styles.mobileFiltersToggle}
              onClick={() => setShowMobileFilters(!showMobileFilters)}
            >
              <i className={`bi ${showMobileFilters ? 'bi-funnel-fill' : 'bi-funnel'}`}></i>
              {showMobileFilters ? 'Masquer les filtres' : 'Afficher les filtres'}
              {hasActiveFilters && <i className="bi bi-dot" style={{ color: 'orange' }}></i>}
            </button>
          )}
          
          <div 
            className={styles.filtersContainer}
            style={isMobile ? { display: showMobileFilters ? 'block' : 'none' } : {}}
          >
            <div className={styles.filters}>
              {filterOptions.map((filter) => (
                <div key={filter.id} className={styles.filterItem}>
                  <label className={styles.filterLabel}>{filter.label}</label>
                  
                  {filter.type === 'select' && (
                    <select
                      className={styles.filterSelect}
                      value={filterValues[filter.id] || ''}
                      onChange={(e) => handleFilterChange(filter.id, e.target.value)}
                    >
                      <option value="">{filter.placeholder || 'Tous'}</option>
                      {filter.options.map((option) => (
                        <option key={option.value} value={option.value}>
                          {option.label}
                        </option>
                      ))}
                    </select>
                  )}
                  
                  {filter.type === 'text' && (
                    <input
                      type="text"
                      className={styles.filterInput}
                      value={filterValues[filter.id] || ''}
                      onChange={(e) => handleFilterChange(filter.id, e.target.value)}
                      placeholder={filter.placeholder || 'Rechercher...'}
                    />
                  )}
                  
                  {filter.type === 'date' && (
                    <input
                      type="date"
                      className={styles.filterInput}
                      value={filterValues[filter.id] || ''}
                      onChange={(e) => handleFilterChange(filter.id, e.target.value)}
                    />
                  )}
                </div>
              ))}
            </div>
            
            <div className={styles.filterActions}>
              <button 
                className={styles.applyButton} 
                onClick={handleFilterApply}
              >
                Appliquer
              </button>
              {hasActiveFilters && (
                <button 
                  className={styles.resetButton} 
                  onClick={handleFilterReset}
                >
                  R√©initialiser
                </button>
              )}
              {showAdvancedFilters && (
                <button 
                  className={styles.advancedFiltersButton} 
                  onClick={() => setShowAdvancedFiltersPanel(!showAdvancedFiltersPanel)}
                >
                  <i className={`bi ${showAdvancedFiltersPanel ? 'bi-funnel-fill' : 'bi-funnel'}`}></i>
                  Filtres avanc√©s
                  {Object.keys(advancedFilterValues).filter(key => advancedFilterValues[key] && advancedFilterValues[key] !== '').length > 0 && (
                    <span className={styles.filterBadge}>
                      {Object.keys(advancedFilterValues).filter(key => advancedFilterValues[key] && advancedFilterValues[key] !== '').length}
                    </span>
                  )}
                </button>
              )}
            </div>
          </div>
          
          {/* Panel des filtres avanc√©s */}
          {showAdvancedFilters && showAdvancedFiltersPanel && (
            <div className={styles.advancedFiltersPanel}>
              <div className={styles.advancedFiltersGrid}>
                {advancedFilterOptions.map((filter) => (
                  <div key={filter.id} className={styles.advancedFilterItem}>
                    <label className={styles.filterLabel}>{filter.label}</label>
                    
                    {filter.type === 'select' && (
                      <select
                        className={styles.filterSelect}
                        value={advancedFilterValues[filter.id] || ''}
                        onChange={(e) => handleAdvancedFilterChange(filter.id, e.target.value)}
                      >
                        <option value="">{filter.placeholder || 'Tous'}</option>
                        {filter.options.map((option) => (
                          <option key={option.value} value={option.value}>
                            {option.label}
                          </option>
                        ))}
                      </select>
                    )}
                    
                    {filter.type === 'text' && (
                      <input
                        type="text"
                        className={styles.filterInput}
                        value={advancedFilterValues[filter.id] || ''}
                        onChange={(e) => handleAdvancedFilterChange(filter.id, e.target.value)}
                        placeholder={filter.placeholder || 'Rechercher...'}
                      />
                    )}
                    
                    {filter.type === 'boolean' && (
                      <select
                        className={styles.filterSelect}
                        value={advancedFilterValues[filter.id] || ''}
                        onChange={(e) => handleAdvancedFilterChange(filter.id, e.target.value)}
                      >
                        <option value="">Tous</option>
                        <option value="true">Oui</option>
                        <option value="false">Non</option>
                      </select>
                    )}
                  </div>
                ))}
              </div>
              
              <div className={styles.advancedFilterActions}>
                <button 
                  className={styles.applyButton} 
                  onClick={handleAdvancedFilterApply}
                >
                  Appliquer les filtres avanc√©s
                </button>
                {Object.keys(advancedFilterValues).some(key => advancedFilterValues[key] && advancedFilterValues[key] !== '') && (
                  <button 
                    className={styles.resetButton} 
                    onClick={handleAdvancedFilterReset}
                  >
                    R√©initialiser
                  </button>
                )}
              </div>
            </div>
          )}
        </>
      )}
      
      <div className={styles.tableWrapper}>
        <table className={styles.table}>
          <thead>
            <tr>
              {columns.map((column) => (
                <th 
                  key={column.id} 
                  className={`${styles.tableHeader} ${column.sortable ? styles.sortable : ''}`}
                  style={{ '--column-width': column.width || 'auto' }}
                  onClick={() => column.sortable && handleSort(column.field)}
                >
                  <div className={styles.headerContent}>
                    <span>{column.label}</span>
                    {column.sortable && (
                      <div className={styles.sortIcon}>
                        {sort.field === column.field ? (
                          sort.direction === 'asc' ? (
                            <i className="bi bi-caret-up-fill"></i>
                          ) : (
                            <i className="bi bi-caret-down-fill"></i>
                          )
                        ) : (
                          <i className="bi bi-caret-down"></i>
                        )}
                      </div>
                    )}
                  </div>
                </th>
              ))}
              {renderActions && (
                <th className={styles.tableHeader} style={{ width: '120px' }}>
                  Actions
                </th>
              )}
            </tr>
          </thead>
          <tbody>
            {items.length === 0 ? (
              <tr>
                <td colSpan={columns.length + (renderActions ? 1 : 0)} className={styles.noData}>
                  {loading ? (
                    <div className={styles.loading}>
                      <i className="bi bi-hourglass-split"></i>
                      <span>Chargement...</span>
                    </div>
                  ) : (
                    <div className={styles.noResults}>
                      <i className="bi bi-search"></i>
                      <span>Aucun r√©sultat trouv√©</span>
                    </div>
                  )}
                </td>
              </tr>
            ) : (
              items.map((item) => (
                <tr 
                  key={item.id} 
                  className={styles.tableRow}
                  onClick={() => handleRowClick(item)}
                >
                  {columns.map((column) => (
                    <td 
                      key={`${item.id}-${column.id}`} 
                      className={styles.tableCell}
                    >
                      {renderColumnValue(item, column)}
                    </td>
                  ))}
                  {renderActions && (
                    <td 
                      className={styles.tableCell} 
                      onClick={(e) => e.stopPropagation()}
                    >
                      {renderActions(item)}
                    </td>
                  )}
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
      
      {/* Conteneur des cartes mobiles */}
      <div className={styles.mobileCardsContainer}>
        {items.length === 0 ? (
          <div className={styles.noData}>
            {loading ? (
              <div className={styles.loading}>
                <i className="bi bi-hourglass-split"></i>
                <span>Chargement...</span>
              </div>
            ) : (
              <div className={styles.noResults}>
                <i className="bi bi-search"></i>
                <span>Aucun r√©sultat trouv√©</span>
              </div>
            )}
          </div>
        ) : (
          items.map((item) => renderMobileCard(item))
        )}
      </div>
      
      {hasMore && !loading && (
        <div className={styles.loadMoreContainer}>
          <button 
            className={styles.loadMoreButton} 
            onClick={handleLoadMore}
          >
            Charger plus
          </button>
        </div>
      )}
      
      {loading && items.length > 0 && (
        <div className={styles.loadingMoreContainer}>
          <i className="bi bi-hourglass-split"></i>
          <span>Chargement...</span>
        </div>
      )}
    </div>
  );
};

ListWithFilters.propTypes = {
  entityType: PropTypes.string.isRequired,
  title: PropTypes.string,
  columns: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.string.isRequired,
      label: PropTypes.string.isRequired,
      field: PropTypes.string,
      sortable: PropTypes.bool,
      width: PropTypes.string,
      render: PropTypes.func,
    })
  ).isRequired,
  filters: PropTypes.object,
  sort: PropTypes.shape({
    field: PropTypes.string,
    direction: PropTypes.oneOf(['asc', 'desc']),
  }),
  actions: PropTypes.node,
  onRowClick: PropTypes.func,
  pageSize: PropTypes.number,
  showRefresh: PropTypes.bool,
  filterOptions: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.string.isRequired,
      label: PropTypes.string.isRequired,
      field: PropTypes.string.isRequired,
      type: PropTypes.oneOf(['text', 'select', 'date']).isRequired,
      options: PropTypes.arrayOf(
        PropTypes.shape({
          value: PropTypes.string.isRequired,
          label: PropTypes.string.isRequired,
        })
      ),
      placeholder: PropTypes.string,
    })
  ),
  renderActions: PropTypes.func,
  calculateStats: PropTypes.func,
  showStats: PropTypes.bool,
  showAdvancedFilters: PropTypes.bool,
  advancedFilterOptions: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.string.isRequired,
      label: PropTypes.string.isRequired,
      field: PropTypes.string.isRequired,
      type: PropTypes.oneOf(['text', 'select', 'boolean']).isRequired,
      options: PropTypes.arrayOf(
        PropTypes.shape({
          value: PropTypes.string.isRequired,
          label: PropTypes.string.isRequired,
        })
      ),
      placeholder: PropTypes.string,
    })
  ),
};

export default ListWithFilters;