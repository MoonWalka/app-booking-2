#!/usr/bin/env node

/**
 * Script de test COMPLET et √âTENDU des re-renders
 * 
 * Ce script teste TOUTES les pages de l'application :
 * - Toutes les pages d'√©dition et de cr√©ation
 * - Toutes les pages de d√©tails
 * - Toutes les pages de listes
 * - Pages sp√©cialis√©es (param√®tres, contrats, etc.)
 */

const puppeteer = require('puppeteer');
const { spawn } = require('child_process');

console.log('üß™ Test COMPLET et √âTENDU des re-renders (TOUTES les pages)');
console.log('============================================================');

// Configuration
const TEST_DURATION_PER_PAGE = 6000; // 6 secondes par page
const APP_URL = 'http://localhost:3000';

// TOUTES les pages √† tester - COUVERTURE COMPL√àTE
const ALL_PAGES_TO_TEST = [
  // === PAGES PRINCIPALES ===
  {
    name: 'Accueil',
    url: '/',
    actions: ['wait:1000']
  },

  // === CONCERTS ===
  {
    name: 'Liste des concerts',
    url: '/concerts',
    actions: ['wait:2000']
  },
  {
    name: 'Nouveau concert',
    url: '/concerts/nouveau',
    actions: [
      'wait:2000',
      'type:input[name="titre"]:Concert Test Nouveau',
      'wait:1000'
    ]
  },
  {
    name: 'D√©tail concert',
    url: '/concerts/con-1747960488398-mwb0vm',
    actions: ['wait:3000']
  },
  {
    name: '√âdition concert',
    url: '/concerts/con-1747960488398-mwb0vm/edit',
    actions: [
      'wait:2000',
      'type:input[name="titre"]:Concert Test Modifi√©',
      'wait:1000'
    ]
  },

  // === PROGRAMMATEURS ===
  {
    name: 'Liste des programmateurs',
    url: '/programmateurs',
    actions: ['wait:2000']
  },
  {
    name: 'Nouveau programmateur',
    url: '/programmateurs/nouveau',
    actions: [
      'wait:2000',
      'type:input[name="nom"]:Test Programmateur Nouveau',
      'type:input[name="email"]:test@programmateur.com',
      'wait:1000'
    ]
  },
  {
    name: 'D√©tail programmateur',
    url: '/programmateurs/prog-1747960488398-test',
    actions: ['wait:2000']
  },
  {
    name: '√âdition programmateur',
    url: '/programmateurs/prog-1747960488398-test/edit',
    actions: [
      'wait:2000',
      'type:input[name="nom"]:Programmateur Modifi√©',
      'wait:1000'
    ]
  },

  // === ARTISTES ===
  {
    name: 'Liste des artistes',
    url: '/artistes',
    actions: ['wait:2000']
  },
  {
    name: 'Nouveau artiste',
    url: '/artistes/nouveau',
    actions: [
      'wait:2000',
      'type:input[name="nom"]:Artiste Test Nouveau',
      'wait:1000'
    ]
  },
  {
    name: 'D√©tail artiste',
    url: '/artistes/art-1747960488398-test',
    actions: ['wait:2000']
  },
  {
    name: '√âdition artiste',
    url: '/artistes/art-1747960488398-test/modifier',
    actions: [
      'wait:2000',
      'type:input[name="nom"]:Artiste Modifi√©',
      'wait:1000'
    ]
  },

  // === LIEUX ===
  {
    name: 'Liste des lieux',
    url: '/lieux',
    actions: ['wait:2000']
  },
  {
    name: 'Nouveau lieu',
    url: '/lieux/nouveau',
    actions: [
      'wait:2000',
      'type:input[name="nom"]:Lieu Test Nouveau',
      'type:input[name="ville"]:Paris Test',
      'wait:1000'
    ]
  },
  {
    name: 'D√©tail lieu',
    url: '/lieux/lieu-1747960488398-test',
    actions: ['wait:2000']
  },
  {
    name: '√âdition lieu',
    url: '/lieux/lieu-1747960488398-test/edit',
    actions: [
      'wait:2000',
      'type:input[name="nom"]:Lieu Modifi√©',
      'wait:1000'
    ]
  },

  // === STRUCTURES ===
  {
    name: 'Liste des structures',
    url: '/structures',
    actions: ['wait:2000']
  },
  {
    name: 'Nouvelle structure',
    url: '/structures/nouveau',
    actions: [
      'wait:2000',
      'type:input[name="raisonSociale"]:Structure Test Nouvelle',
      'wait:1000'
    ]
  },
  {
    name: 'D√©tail structure',
    url: '/structures/struct-1747960488398-test',
    actions: ['wait:2000']
  },
  {
    name: '√âdition structure',
    url: '/structures/struct-1747960488398-test/edit',
    actions: [
      'wait:2000',
      'type:input[name="raisonSociale"]:Structure Modifi√©e',
      'wait:1000'
    ]
  },

  // === PARAM√àTRES ===
  {
    name: 'Param√®tres - Entreprise',
    url: '/parametres',
    actions: ['wait:2000']
  },
  {
    name: 'Param√®tres - G√©n√©raux',
    url: '/parametres/generaux',
    actions: ['wait:2000']
  },
  {
    name: 'Param√®tres - Compte',
    url: '/parametres/compte',
    actions: ['wait:2000']
  },
  {
    name: 'Param√®tres - Notifications',
    url: '/parametres/notifications',
    actions: ['wait:2000']
  },
  {
    name: 'Param√®tres - Apparence',
    url: '/parametres/apparence',
    actions: ['wait:2000']
  },
  {
    name: 'Param√®tres - Export',
    url: '/parametres/export',
    actions: ['wait:2000']
  },
  {
    name: 'Param√®tres - Synchronisation',
    url: '/parametres/sync',
    actions: ['wait:2000']
  },

  // === MOD√àLES DE CONTRATS ===
  {
    name: 'Mod√®les de contrats',
    url: '/parametres/contrats',
    actions: [
      'wait:2000',
      'click:button:contains("Cr√©er un mod√®le")',
      'wait:1000'
    ]
  },
  {
    name: '√âdition mod√®le de contrat',
    url: '/parametres/contrats/template-test',
    actions: [
      'wait:3000',
      'type:input[name="name"]:Mod√®le Test Modifi√©',
      'wait:1000'
    ]
  },

  // === G√âN√âRATION DE CONTRATS ===
  {
    name: 'G√©n√©ration de contrat',
    url: '/contrats/generation/con-1747960488398-mwb0vm',
    actions: ['wait:3000']
  }
];

// Compteurs globaux √©tendus
const globalStats = {
  renderCounts: new Map(),
  hookCalls: new Map(),
  componentMounts: new Map(),
  consoleErrors: [],
  pageResults: new Map(),
  categoryStats: new Map()
};

let appProcess = null;
let browser = null;
let page = null;

// Fonction pour analyser les logs de console (am√©lior√©e)
function analyzeConsoleMessage(msg, currentPageName) {
  const text = msg.text();
  const timestamp = Date.now();
  
  // D√©tecter les re-renders de why-did-you-render
  if (text.includes('Re-rendered because of hook changes') || text.includes('Re-rendered because')) {
    const match = text.match(/(\w+)\s+Re-rendered/);
    if (match) {
      const component = match[1];
      const key = `${currentPageName}:${component}`;
      globalStats.renderCounts.set(key, (globalStats.renderCounts.get(key) || 0) + 1);
      console.log(`üîÑ [${currentPageName}] Re-render: ${component} (${globalStats.renderCounts.get(key)})`);
    }
  }
  
  // D√©tecter les appels de hooks
  if (text.includes('Hook called') || text.includes('INIT:') || text.includes('useEffect')) {
    const hookMatch = text.match(/(use\w+)/);
    if (hookMatch) {
      const hook = hookMatch[1];
      const key = `${currentPageName}:${hook}`;
      globalStats.hookCalls.set(key, (globalStats.hookCalls.get(key) || 0) + 1);
    }
  }
  
  // D√©tecter les montages de composants
  if (text.includes('Montage avec id') || text.includes('mounted') || text.includes('Component mounted')) {
    const componentMatch = text.match(/(\w+View|\w+List|\w+Form|\w+Details|\w+Page)/);
    if (componentMatch) {
      const component = componentMatch[1];
      const key = `${currentPageName}:${component}`;
      globalStats.componentMounts.set(key, (globalStats.componentMounts.get(key) || 0) + 1);
      console.log(`üèóÔ∏è [${currentPageName}] Montage: ${component} (${globalStats.componentMounts.get(key)})`);
    }
  }
  
  // D√©tecter les erreurs et warnings
  if (msg.type() === 'error' || msg.type() === 'warning') {
    globalStats.consoleErrors.push({
      message: text,
      page: currentPageName,
      timestamp,
      type: msg.type()
    });
    const icon = msg.type() === 'error' ? '‚ùå' : '‚ö†Ô∏è';
    console.log(`${icon} [${currentPageName}] ${msg.type()}: ${text.substring(0, 60)}...`);
  }
}

// Fonction pour ex√©cuter les actions sur une page (am√©lior√©e)
async function executePageActions(page, actions) {
  for (const action of actions) {
    try {
      if (action.startsWith('wait:')) {
        const duration = parseInt(action.split(':')[1]);
        await new Promise(resolve => setTimeout(resolve, duration));
      } else if (action.startsWith('type:')) {
        const parts = action.split(':');
        const selector = parts[1];
        const text = parts[2];
        
        const element = await page.$(selector);
        if (element) {
          await element.click({ clickCount: 3 }); // S√©lectionner tout
          await element.type(text);
        }
      } else if (action.startsWith('click:')) {
        const selector = action.split(':')[1];
        
        if (selector.includes('contains')) {
          // G√©rer les s√©lecteurs avec :contains()
          const textMatch = selector.match(/contains\("([^"]+)"\)/);
          if (textMatch) {
            const buttonText = textMatch[1];
            await page.evaluate((text) => {
              const buttons = Array.from(document.querySelectorAll('button'));
              const button = buttons.find(b => b.textContent.includes(text));
              if (button) button.click();
            }, buttonText);
          }
        } else {
          const element = await page.$(selector);
          if (element) {
            await element.click();
          }
        }
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è Action √©chou√©e: ${action} - ${error.message}`);
    }
  }
}

// Fonction pour d√©terminer la cat√©gorie d'une page
function getPageCategory(pageName) {
  if (pageName.includes('Concert')) return 'Concerts';
  if (pageName.includes('Programmateur')) return 'Programmateurs';
  if (pageName.includes('Artiste')) return 'Artistes';
  if (pageName.includes('Lieu')) return 'Lieux';
  if (pageName.includes('Structure')) return 'Structures';
  if (pageName.includes('Param√®tres')) return 'Param√®tres';
  if (pageName.includes('Mod√®le') || pageName.includes('Contrat')) return 'Contrats';
  return 'Autres';
}

// Fonction pour tester une page sp√©cifique (am√©lior√©e)
async function testPage(pageConfig) {
  const { name, url, actions } = pageConfig;
  console.log(`\nüìÑ Test de la page: ${name}`);
  console.log(`üîó URL: ${url}`);
  
  const pageStats = {
    renders: 0,
    hooks: 0,
    mounts: 0,
    errors: 0,
    warnings: 0
  };
  
  try {
    // Naviguer vers la page
    console.log('üöÄ Navigation...');
    await page.goto(`${APP_URL}${url}`, { 
      waitUntil: 'domcontentloaded', 
      timeout: 15000 
    });
    
    console.log('‚úÖ Page charg√©e');
    
    // Attendre la stabilisation
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Ex√©cuter les actions sp√©cifiques √† la page
    if (actions && actions.length > 0) {
      console.log(`üé¨ Ex√©cution de ${actions.length} action(s)...`);
      await executePageActions(page, actions);
    }
    
    // Observer pendant la dur√©e d√©finie
    console.log(`‚è±Ô∏è Observation pendant ${TEST_DURATION_PER_PAGE/1000}s...`);
    await new Promise(resolve => setTimeout(resolve, TEST_DURATION_PER_PAGE));
    
    // Calculer les stats pour cette page
    globalStats.renderCounts.forEach((count, key) => {
      if (key.startsWith(`${name}:`)) {
        pageStats.renders += count;
      }
    });
    
    globalStats.hookCalls.forEach((count, key) => {
      if (key.startsWith(`${name}:`)) {
        pageStats.hooks += count;
      }
    });
    
    globalStats.componentMounts.forEach((count, key) => {
      if (key.startsWith(`${name}:`)) {
        pageStats.mounts += count;
      }
    });
    
    const pageErrors = globalStats.consoleErrors.filter(e => e.page === name);
    pageStats.errors = pageErrors.filter(e => e.type === 'error').length;
    pageStats.warnings = pageErrors.filter(e => e.type === 'warning').length;
    
    // √âvaluer la page
    let status = 'üü¢ EXCELLENT';
    if (pageStats.renders > 15 || pageStats.errors > 0) {
      status = 'üî¥ PROBL√âMATIQUE';
    } else if (pageStats.renders > 8 || pageStats.warnings > 2) {
      status = 'üü° ATTENTION';
    }
    
    console.log(`üìä R√©sultat: ${status} (${pageStats.renders} re-renders, ${pageStats.hooks} hooks, ${pageStats.errors} erreurs, ${pageStats.warnings} warnings)`);
    
    globalStats.pageResults.set(name, { ...pageStats, status });
    
    // Mettre √† jour les stats par cat√©gorie
    const category = getPageCategory(name);
    if (!globalStats.categoryStats.has(category)) {
      globalStats.categoryStats.set(category, { renders: 0, errors: 0, warnings: 0, pages: 0 });
    }
    const catStats = globalStats.categoryStats.get(category);
    catStats.renders += pageStats.renders;
    catStats.errors += pageStats.errors;
    catStats.warnings += pageStats.warnings;
    catStats.pages += 1;
    
  } catch (error) {
    console.log(`‚ùå Erreur lors du test de ${name}: ${error.message}`);
    globalStats.pageResults.set(name, { 
      renders: 0, 
      hooks: 0, 
      mounts: 0, 
      errors: 1, 
      warnings: 0,
      status: 'üî¥ ERREUR',
      error: error.message 
    });
  }
}

// Fonction pour d√©marrer l'application
async function startApp() {
  console.log('üöÄ D√©marrage de l\'application...');
  
  return new Promise((resolve, reject) => {
    appProcess = spawn('npm', ['start'], {
      stdio: ['ignore', 'pipe', 'pipe'],
      env: { ...process.env, BROWSER: 'none' }
    });
    
    let appReady = false;
    
    appProcess.stdout.on('data', (data) => {
      const output = data.toString();
      if (output.includes('webpack compiled') || output.includes('Local:')) {
        if (!appReady) {
          appReady = true;
          console.log('‚úÖ Application pr√™te');
          setTimeout(resolve, 3000);
        }
      }
    });
    
    appProcess.stderr.on('data', (data) => {
      const output = data.toString();
      if (output.includes('EADDRINUSE')) {
        console.log('‚ö†Ô∏è Port 3000 d√©j√† utilis√©, l\'application semble d√©j√† lanc√©e');
        resolve();
      }
    });
    
    setTimeout(() => {
      if (!appReady) {
        console.log('‚ö†Ô∏è Timeout - on continue avec l\'application existante');
        resolve();
      }
    }, 25000);
  });
}

// Fonction pour g√©n√©rer le rapport final √©tendu
function generateExtendedReport() {
  console.log('\nüìä RAPPORT COMPLET √âTENDU - TOUTES LES PAGES');
  console.log('=============================================');
  
  // R√©sum√© par cat√©gorie
  console.log('\nüìÇ R√©sultats par cat√©gorie:');
  globalStats.categoryStats.forEach((stats, category) => {
    const avgRenders = (stats.renders / stats.pages).toFixed(1);
    let categoryStatus = 'üü¢';
    if (stats.errors > 0 || stats.renders > 30) {
      categoryStatus = 'üî¥';
    } else if (stats.warnings > 3 || stats.renders > 15) {
      categoryStatus = 'üü°';
    }
    
    console.log(`  ${categoryStatus} ${category} (${stats.pages} pages):`);
    console.log(`    üîÑ ${stats.renders} re-renders (moy: ${avgRenders})`);
    console.log(`    ‚ùå ${stats.errors} erreurs`);
    console.log(`    ‚ö†Ô∏è ${stats.warnings} warnings`);
  });
  
  // R√©sum√© par page (top 10 probl√©matiques)
  console.log('\nüìÑ Top 10 des pages les plus probl√©matiques:');
  const sortedPages = Array.from(globalStats.pageResults.entries())
    .sort((a, b) => (b[1].renders + b[1].errors * 20 + b[1].warnings * 5) - (a[1].renders + a[1].errors * 20 + a[1].warnings * 5))
    .slice(0, 10);
  
  sortedPages.forEach(([pageName, stats], index) => {
    const score = stats.renders + stats.errors * 20 + stats.warnings * 5;
    if (score > 0) {
      console.log(`  ${index + 1}. ${pageName}: ${score} points`);
      console.log(`     üîÑ ${stats.renders} re-renders, ‚ùå ${stats.errors} erreurs, ‚ö†Ô∏è ${stats.warnings} warnings`);
    }
  });
  
  if (sortedPages.every(([, stats]) => stats.renders + stats.errors * 20 + stats.warnings * 5 === 0)) {
    console.log('  ‚úÖ Aucune page probl√©matique d√©tect√©e');
  }
  
  // Statistiques globales
  const totalRenders = Array.from(globalStats.renderCounts.values()).reduce((a, b) => a + b, 0);
  const totalHooks = Array.from(globalStats.hookCalls.values()).reduce((a, b) => a + b, 0);
  const totalMounts = Array.from(globalStats.componentMounts.values()).reduce((a, b) => a + b, 0);
  const totalErrors = globalStats.consoleErrors.filter(e => e.type === 'error').length;
  const totalWarnings = globalStats.consoleErrors.filter(e => e.type === 'warning').length;
  const totalPages = ALL_PAGES_TO_TEST.length;
  
  console.log('\nüåç Statistiques globales:');
  console.log(`  üìÑ Pages test√©es: ${totalPages}`);
  console.log(`  üîÑ Total re-renders: ${totalRenders} (moy: ${(totalRenders/totalPages).toFixed(1)} par page)`);
  console.log(`  üé£ Total appels hooks: ${totalHooks}`);
  console.log(`  üèóÔ∏è Total montages: ${totalMounts}`);
  console.log(`  ‚ùå Total erreurs: ${totalErrors}`);
  console.log(`  ‚ö†Ô∏è Total warnings: ${totalWarnings}`);
  
  // Score global √©tendu
  const globalScore = Math.max(0, 100 - totalRenders * 1.5 - totalErrors * 15 - totalWarnings * 3);
  console.log('\nüéØ SCORE GLOBAL √âTENDU:');
  console.log(`üìà ${globalScore.toFixed(1)}/100`);
  
  if (globalScore >= 95) {
    console.log('üü¢ EXCELLENT - Application parfaitement optimis√©e sur TOUTES les pages');
  } else if (globalScore >= 85) {
    console.log('üü° TR√àS BON - Application bien optimis√©e avec quelques am√©liorations mineures');
  } else if (globalScore >= 70) {
    console.log('üü† BON - Application correctement optimis√©e avec quelques points d\'attention');
  } else if (globalScore >= 50) {
    console.log('üü† MOYEN - Optimisations recommand√©es sur plusieurs pages');
  } else {
    console.log('üî¥ PROBL√âMATIQUE - Optimisations urgentes n√©cessaires');
  }
  
  // Recommandations √©tendues
  console.log('\nüí° Recommandations d√©taill√©es:');
  if (totalRenders > 50) {
    console.log('  üîß Optimiser les hooks avec trop de re-renders');
    console.log('  üîß V√©rifier les d√©pendances des useEffect et useMemo');
  }
  if (totalErrors > 0) {
    console.log('  üêõ Corriger les erreurs JavaScript d√©tect√©es');
  }
  if (totalWarnings > 5) {
    console.log('  ‚ö†Ô∏è Examiner et corriger les warnings React');
  }
  if (globalScore >= 95) {
    console.log('  üéâ F√©licitations ! Application excellemment optimis√©e sur toutes les pages');
  }
  
  // Couverture des tests
  console.log('\nüìã Couverture des tests:');
  console.log('  ‚úÖ Pages de listes: Compl√®te');
  console.log('  ‚úÖ Pages de cr√©ation: Compl√®te');
  console.log('  ‚úÖ Pages d\'√©dition: Compl√®te');
  console.log('  ‚úÖ Pages de d√©tails: Compl√®te');
  console.log('  ‚úÖ Pages de param√®tres: Compl√®te');
  console.log('  ‚úÖ Pages de contrats: Compl√®te');
  console.log(`  üìä Total: ${totalPages} pages test√©es`);
}

// Fonction de nettoyage
async function cleanup() {
  console.log('\nüßπ Nettoyage...');
  
  if (page) {
    await page.close();
  }
  
  if (browser) {
    await browser.close();
  }
  
  if (appProcess && !appProcess.killed) {
    appProcess.kill('SIGTERM');
  }
}

// Fonction principale
async function main() {
  try {
    // D√©marrer l'application
    await startApp();
    
    // Lancer le navigateur
    console.log('üåê Lancement du navigateur headless...');
    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    page = await browser.newPage();
    
    console.log(`\nüéØ Test de ${ALL_PAGES_TO_TEST.length} pages au total`);
    console.log('‚è±Ô∏è Dur√©e estim√©e: ' + Math.ceil(ALL_PAGES_TO_TEST.length * TEST_DURATION_PER_PAGE / 1000 / 60) + ' minutes');
    
    // Tester chaque page
    for (let i = 0; i < ALL_PAGES_TO_TEST.length; i++) {
      const pageConfig = ALL_PAGES_TO_TEST[i];
      console.log(`\n[${i + 1}/${ALL_PAGES_TO_TEST.length}] ==================`);
      
      // Configurer l'√©coute des logs pour cette page
      page.removeAllListeners('console');
      page.on('console', (msg) => analyzeConsoleMessage(msg, pageConfig.name));
      
      await testPage(pageConfig);
    }
    
    // G√©n√©rer le rapport final √©tendu
    generateExtendedReport();
    
  } catch (error) {
    console.error('‚ùå Erreur lors du test complet √©tendu:', error);
  } finally {
    await cleanup();
  }
}

// Gestion des signaux
process.on('SIGINT', async () => {
  console.log('\nüõë Arr√™t du test...');
  await cleanup();
  process.exit(0);
});

// Lancer le test
main().catch(async (error) => {
  console.error('‚ùå Erreur fatale:', error);
  await cleanup();
  process.exit(1);
}); 