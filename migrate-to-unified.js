#!/usr/bin/env node

/**
 * Script de Migration vers Architecture Unifi√©e
 * 
 * Consolide les collections s√©par√©es en documents unifi√©s:
 * - contacts (6 personnes) + structures (6 structures) 
 * ‚Üí contacts_unified (3-4 documents structure+personnes)
 * 
 * Date: 18 juin 2025
 * Compatibilit√©: Architecture Business-centr√©e + XLS naturel
 */

const { initializeApp } = require('firebase/app');
const { 
  getFirestore, 
  collection, 
  doc, 
  getDocs, 
  setDoc, 
  query, 
  where,
  serverTimestamp 
} = require('firebase/firestore');

// Configuration Firebase
const firebaseConfig = {
  apiKey: "AIzaSyD2nrKWoEBvEbjbopk26rrGbCYZDNpJ8BU",
  authDomain: "app-booking-26571.firebaseapp.com", 
  projectId: "app-booking-26571",
  storageBucket: "app-booking-26571.firebasestorage.app",
  messagingSenderId: "985724562753",
  appId: "1:985724562753:web:253b7e7c678318b69a85c0"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/**
 * Charge toutes les donn√©es actuelles
 */
async function loadCurrentData() {
  console.log('üìä Chargement des donn√©es actuelles...');
  
  // Charger contacts
  const contactsSnapshot = await getDocs(collection(db, 'contacts'));
  const contacts = contactsSnapshot.docs.map(doc => ({ 
    id: doc.id, 
    ...doc.data() 
  }));
  
  // Charger structures
  const structuresSnapshot = await getDocs(collection(db, 'structures'));
  const structures = structuresSnapshot.docs.map(doc => ({ 
    id: doc.id, 
    ...doc.data() 
  }));
  
  console.log(`   Contacts trouv√©s: ${contacts.length}`);
  console.log(`   Structures trouv√©es: ${structures.length}`);
  
  return { contacts, structures };
}

/**
 * Groupe les contacts par structure
 */
function groupContactsByStructure(contacts, structures) {
  console.log('üîó Groupement des contacts par structure...');
  
  const groups = [];
  const processedContacts = new Set();
  
  // Grouper les contacts avec structure
  structures.forEach(structure => {
    const relatedContacts = contacts.filter(contact => 
      contact.structureId === structure.id
    );
    
    // Inclure toutes les structures, m√™me sans contacts
    groups.push({
      type: 'structure',
      structure: structure,
      contacts: relatedContacts
    });
    
    // Marquer les contacts comme trait√©s
    relatedContacts.forEach(contact => {
      processedContacts.add(contact.id);
    });
    
    if (relatedContacts.length === 0) {
      console.log(`   ‚ÑπÔ∏è Structure sans contact: ${structure.raisonSociale || structure.id} (sera incluse)`);
    }
  });
  
  // Contacts libres (sans structure)
  const freeContacts = contacts.filter(contact => 
    !processedContacts.has(contact.id)
  );
  
  if (freeContacts.length > 0) {
    groups.push({
      type: 'personnes_libres',
      structure: null,
      contacts: freeContacts
    });
  }
  
  console.log(`   Groupes cr√©√©s: ${groups.length}`);
  console.log(`   - Avec structure: ${groups.filter(g => g.type === 'structure').length}`);
  console.log(`   - Personnes libres: ${freeContacts.length}`);
  
  return groups;
}

/**
 * Convertit un contact en objet personne unifi√©
 */
function mapContactToPersonne(contact) {
  return {
    civilite: contact.civilite || "",
    prenom: contact.prenom || "",
    nom: contact.nom || "",
    fonction: contact.fonction || "",
    
    // Emails
    email: contact.email || "",
    mailDirect: contact.mailDirect || "",
    mailPerso: contact.mailPerso || "",
    
    // T√©l√©phones
    telephone: contact.telephone || "",
    telDirect: contact.telDirect || "",
    telPerso: contact.telPerso || "",
    mobile: contact.mobile || "",
    fax: contact.fax || "",
    
    // Adresse (si diff√©rente de structure)
    adresse: contact.adresse || "",
    suiteAdresse: contact.suiteAdresse || "",
    codePostal: contact.codePostal || "",
    ville: contact.ville || "",
    departement: contact.departement || "",
    region: contact.region || "",
    pays: contact.pays || "France",
    
    // Commentaires
    commentaires1: contact.commentaires1 || "",
    commentaires2: contact.commentaires2 || "",
    commentaires3: contact.commentaires3 || "",
    
    // Diffusion
    diffusionCommentaires1: contact.diffusionCommentaires1 || "",
    diffusionCommentaires2: contact.diffusionCommentaires2 || "",
    diffusionCommentaires3: contact.diffusionCommentaires3 || ""
  };
}

/**
 * Convertit une structure en objet structure unifi√©
 */
function mapStructureToUnified(structure) {
  return {
    raisonSociale: structure.raisonSociale || "",
    nom: structure.nom || structure.raisonSociale || "",
    
    // Adresse
    adresse: structure.adresse || "",
    suiteAdresse: structure.suiteAdresse1 || "",
    codePostal: structure.codePostal || "",
    ville: structure.ville || "",
    departement: structure.departement || "",
    region: structure.region || "",
    pays: structure.pays || "France",
    
    // Contact
    email: structure.email || "",
    telephone1: structure.telephone1 || "",
    telephone2: structure.telephone2 || "",
    mobile: structure.mobile || "",
    fax: structure.fax || "",
    siteWeb: structure.siteWeb || "",
    
    // Donn√©es l√©gales
    siret: structure.siret || "",
    tva: structure.tva || "",
    numeroIntracommunautaire: structure.numeroIntracommunautaire || "",
    type: structure.type || "",
    
    // Commentaires
    commentaires1: structure.commentaires1 || "",
    commentaires2: structure.commentaires2 || "",
    commentaires3: structure.commentaires3 || "",
    commentaires4: structure.commentaires4 || "",
    commentaires5: structure.commentaires5 || "",
    commentaires6: structure.commentaires6 || "",
    
    // √âv√©nement
    nomFestival: structure.nomFestival || "",
    periodeFestivalMois: structure.periodeFestivalMois || "",
    periodeFestivalComplete: structure.periodeFestivalComplete || "",
    
    // Salle (donn√©es complexes)
    salle: {
      nom: structure.salleNom || "",
      adresse: structure.salleAdresse || "",
      codePostal: structure.salleCodePostal || "",
      ville: structure.salleVille || "",
      departement: structure.salleDepartement || "",
      region: structure.salleRegion || "",
      pays: structure.sallePays || "France",
      telephone: structure.salleTelephone || "",
      jauge1: structure.salleJauge1 || "",
      jauge2: structure.salleJauge2 || "",
      jauge3: structure.salleJauge3 || "",
      hauteur: structure.salleHauteur || "",
      profondeur: structure.salleProfondeur || "",
      ouverture: structure.salleOuverture || ""
    }
  };
}

/**
 * Cr√©e les documents unifi√©s
 */
function createUnifiedDocuments(groups) {
  console.log('üìù Cr√©ation des documents unifi√©s...');
  
  const unifiedDocs = [];
  
  groups.forEach((group, index) => {
    if (group.type === 'structure') {
      // Document structure + personnes
      const structureData = mapStructureToUnified(group.structure);
      const personnesData = group.contacts.map(mapContactToPersonne);
      
      // Compl√©ter avec des personnes vides pour avoir toujours 3 slots
      while (personnesData.length < 3) {
        personnesData.push({
          civilite: "", prenom: "", nom: "", fonction: "",
          email: "", telephone: "", pays: "France"
        });
      }
      
      const unifiedDoc = {
        id: `unified_structure_${group.structure.id}`,
        entityType: 'structure',
        
        // Donn√©es structure
        structure: structureData,
        
        // Personnes associ√©es (max 3)
        personnes: personnesData,
        
        // M√©tadonn√©es syst√®me
        organizationId: group.structure.organizationId || group.contacts[0]?.organizationId || "default_org",
        statut: "actif",
        client: group.structure.client || false,
        source: "migration",
        tags: group.structure.tags || [],
        
        // Relations business (pr√©serv√©es)
        concertsIds: group.contacts.flatMap(c => c.concertsIds || []),
        lieuxIds: group.contacts.flatMap(c => c.lieuxIds || []),
        artistesIds: group.contacts.flatMap(c => c.artistesIds || []),
        
        // M√©tadonn√©es techniques
        createdAt: group.structure.createdAt || serverTimestamp(),
        updatedAt: serverTimestamp(),
        dateDerniereModif: serverTimestamp(),
        
        // Migration
        migrationVersion: "unified-v2",
        migratedFrom: {
          structureId: group.structure.id,
          contactIds: group.contacts.map(c => c.id)
        },
        migrationNote: `Unifi√© depuis structure ${group.structure.id} + ${group.contacts.length} contacts`,
        migrationDate: serverTimestamp()
      };
      
      unifiedDocs.push(unifiedDoc);
      
      console.log(`   ‚úÖ Structure: ${structureData.raisonSociale} (${group.contacts.length} personnes)`);
      
    } else if (group.type === 'personnes_libres') {
      // Documents personne libre s√©par√©s
      group.contacts.forEach(contact => {
        const personneData = mapContactToPersonne(contact);
        
        const unifiedDoc = {
          id: `unified_personne_${contact.id}`,
          entityType: 'personne_libre',
          
          // Donn√©es personne
          personne: personneData,
          
          // Pas de structure
          structure: null,
          personnes: [],
          
          // M√©tadonn√©es syst√®me
          organizationId: contact.organizationId || "default_org",
          statut: contact.statut || "actif",
          client: contact.client || false,
          source: "migration",
          tags: contact.tags || [],
          
          // Relations business
          concertsIds: contact.concertsIds || [],
          lieuxIds: contact.lieuxIds || [],
          artistesIds: contact.artistesIds || [],
          
          // M√©tadonn√©es techniques
          createdAt: contact.createdAt || serverTimestamp(),
          updatedAt: serverTimestamp(),
          dateDerniereModif: serverTimestamp(),
          
          // Migration
          migrationVersion: "unified-v2",
          migratedFrom: {
            contactId: contact.id
          },
          migrationNote: `Personne libre migr√©e depuis contact ${contact.id}`,
          migrationDate: serverTimestamp()
        };
        
        unifiedDocs.push(unifiedDoc);
        
        console.log(`   ‚úÖ Personne libre: ${personneData.prenom} ${personneData.nom}`);
      });
    }
  });
  
  console.log(`üìã Total documents unifi√©s cr√©√©s: ${unifiedDocs.length}`);
  return unifiedDocs;
}

/**
 * Sauvegarde les documents unifi√©s
 */
async function saveUnifiedDocuments(unifiedDocs) {
  console.log('üíæ Sauvegarde des documents unifi√©s...');
  
  for (const unifiedDoc of unifiedDocs) {
    try {
      await setDoc(doc(db, 'contacts_unified', unifiedDoc.id), unifiedDoc);
      console.log(`   ‚úÖ Sauvegard√©: ${unifiedDoc.id}`);
    } catch (error) {
      console.error(`   ‚ùå Erreur sauvegarde ${unifiedDoc.id}:`, error.message);
      throw error;
    }
  }
  
  console.log('‚úÖ Tous les documents unifi√©s sauvegard√©s');
}

/**
 * Valide la migration
 */
async function validateMigration(originalData, unifiedDocs) {
  console.log('üîç Validation de la migration...');
  
  const { contacts, structures } = originalData;
  
  console.log('\nüìä RAPPORT DE MIGRATION:');
  console.log('========================');
  
  // Compteurs originaux
  console.log(`Donn√©es originales:`);
  console.log(`   - Contacts: ${contacts.length}`);
  console.log(`   - Structures: ${structures.length}`);
  console.log(`   - Total documents: ${contacts.length + structures.length}`);
  
  // Compteurs unifi√©s
  const structureDocs = unifiedDocs.filter(d => d.entityType === 'structure');
  const personnesLibres = unifiedDocs.filter(d => d.entityType === 'personne_libre');
  const totalPersonnes = structureDocs.reduce((sum, doc) => {
    return sum + doc.personnes.filter(p => p.prenom && p.nom).length;
  }, 0) + personnesLibres.length;
  
  console.log(`\nDonn√©es unifi√©es:`);
  console.log(`   - Documents structure: ${structureDocs.length}`);
  console.log(`   - Documents personne libre: ${personnesLibres.length}`);
  console.log(`   - Total documents: ${unifiedDocs.length}`);
  console.log(`   - Total personnes: ${totalPersonnes}`);
  
  // Validation
  const expectedPersonnes = contacts.length;
  const expectedStructures = structures.length;
  
  console.log(`\n‚úÖ VALIDATION:`);
  console.log(`   - Personnes conserv√©es: ${totalPersonnes}/${expectedPersonnes} ${totalPersonnes === expectedPersonnes ? '‚úÖ' : '‚ùå'}`);
  console.log(`   - Structures conserv√©es: ${structureDocs.length}/${expectedStructures} ${structureDocs.length === expectedStructures ? '‚úÖ' : '‚ùå'}`);
  console.log(`   - Compression: ${contacts.length + structures.length} ‚Üí ${unifiedDocs.length} documents (-${((contacts.length + structures.length - unifiedDocs.length) / (contacts.length + structures.length) * 100).toFixed(1)}%)`);
  
  // V√©rifier relations business
  const originalConcerts = contacts.flatMap(c => c.concertsIds || []);
  const unifiedConcerts = unifiedDocs.flatMap(d => d.concertsIds || []);
  console.log(`   - Relations concerts: ${unifiedConcerts.length}/${originalConcerts.length} ${unifiedConcerts.length === originalConcerts.length ? '‚úÖ' : '‚ùå'}`);
  
  if (totalPersonnes === expectedPersonnes && structureDocs.length === expectedStructures) {
    console.log('\nüéâ MIGRATION R√âUSSIE - Toutes les donn√©es sont pr√©serv√©es !');
    return true;
  } else {
    console.log('\n‚ùå MIGRATION √âCHOU√âE - Donn√©es manquantes !');
    return false;
  }
}

/**
 * Fonction principale de migration
 */
async function migrateToUnified() {
  console.log('üöÄ MIGRATION VERS ARCHITECTURE UNIFI√âE');
  console.log('======================================\n');
  
  try {
    // 1. Charger donn√©es actuelles
    const originalData = await loadCurrentData();
    
    // 2. Grouper par structure
    const groups = groupContactsByStructure(originalData.contacts, originalData.structures);
    
    // 3. Cr√©er documents unifi√©s
    const unifiedDocs = createUnifiedDocuments(groups);
    
    // 4. Sauvegarder
    await saveUnifiedDocuments(unifiedDocs);
    
    // 5. Valider
    const isValid = await validateMigration(originalData, unifiedDocs);
    
    if (isValid) {
      console.log('\nüéØ MIGRATION TERMIN√âE AVEC SUCC√àS !');
      console.log('Architecture unifi√©e op√©rationnelle.');
      console.log('Prochaines √©tapes:');
      console.log('   1. Adapter ContactsList pour contacts_unified');
      console.log('   2. Cr√©er les hooks useUnifiedContact');
      console.log('   3. Tester l\'interface');
    } else {
      console.log('\n‚ö†Ô∏è MIGRATION PARTIELLEMENT √âCHOU√âE');
      console.log('V√©rifiez les donn√©es et relancez si n√©cessaire.');
    }
    
  } catch (error) {
    console.error('\nüí• ERREUR FATALE:', error.message);
    console.log('Migration interrompue. Donn√©es originales pr√©serv√©es.');
    process.exit(1);
  }
}

// Ex√©cution avec confirmation
async function main() {
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  console.log('üö® ATTENTION: Migration vers architecture unifi√©e');
  console.log('Cette op√©ration va:');
  console.log('   - Cr√©er une nouvelle collection contacts_unified');
  console.log('   - Consolider 6 contacts + 6 structures en documents unifi√©s');
  console.log('   - Pr√©server toutes les donn√©es et relations');
  console.log('   - Permettre import/export XLS naturel\n');
  
  const confirm = await new Promise(resolve => {
    rl.question('Confirmez-vous la migration ? (oui/non): ', answer => {
      resolve(answer.toLowerCase().trim());
    });
  });
  
  rl.close();
  
  if (confirm === 'oui' || confirm === 'o' || confirm === 'y' || confirm === 'yes') {
    await migrateToUnified();
  } else {
    console.log('‚ùå Migration annul√©e');
  }
}

// Point d'entr√©e
if (require.main === module) {
  main().catch(error => {
    console.error('üí• Erreur fatale:', error);
    process.exit(1);
  });
}

module.exports = {
  migrateToUnified,
  loadCurrentData,
  groupContactsByStructure,
  mapContactToPersonne,
  mapStructureToUnified,
  createUnifiedDocuments
};