#!/usr/bin/env node

/**
 * Script de Rollback : contactIds ‚Üí contactId
 * 
 * Annule la migration en restaurant l'ancien syst√®me contactId
 * Utilise les donn√©es sauvegard√©es dans contactId_migrated
 * 
 * ‚ö†Ô∏è  ATTENTION: √Ä utiliser uniquement en cas de probl√®me critique ‚ö†Ô∏è
 * 
 * Usage:
 *   node scripts/rollback-contact-migration.js [--dry-run] [--verbose]
 * 
 * Options:
 *   --dry-run   Simulation sans modification des donn√©es
 *   --verbose   Affichage d√©taill√© des op√©rations
 * 
 * Cr√©√© le : Janvier 2025
 */

const { initializeApp } = require('firebase/app');
const { 
  getFirestore, 
  collection, 
  query, 
  where, 
  getDocs, 
  doc, 
  updateDoc, 
  getDoc,
  serverTimestamp,
  writeBatch 
} = require('firebase/firestore');

// Configuration Firebase
const firebaseConfig = {
  projectId: process.env.VITE_FIREBASE_PROJECT_ID || 'tourcraft-dev',
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Variables de configuration
const DRY_RUN = process.argv.includes('--dry-run');
const VERBOSE = process.argv.includes('--verbose') || DRY_RUN;
const BATCH_SIZE = 50;

// Statistiques de rollback
const stats = {
  totalConcerts: 0,
  concertsToRollback: 0,
  concertsRolledBack: 0,
  concertsSkipped: 0,
  errors: [],
  bidirectionalUpdates: 0
};

/**
 * Fonction principale de rollback
 */
async function rollbackConcertContacts() {
  console.log('‚è™ Rollback contactIds ‚Üí contactId');
  console.log('==================================');
  console.log(`Mode: ${DRY_RUN ? 'üß™ DRY-RUN (simulation)' : '‚ö° LIVE'}`);
  console.log(`Verbeux: ${VERBOSE ? 'Oui' : 'Non'}`);
  console.log('');

  // Confirmation pour √©viter les erreurs
  if (!DRY_RUN) {
    console.log('‚ö†Ô∏è  ATTENTION: Ce script va annuler la migration !');
    console.log('   Les concerts reviendront au syst√®me contactId (un seul contact)');
    console.log('   Seul le premier contact de chaque concert sera conserv√©');
    console.log('');
    console.log('   Appuyez sur Ctrl+C pour annuler ou attendez 10 secondes...');
    
    await new Promise(resolve => setTimeout(resolve, 10000));
    console.log('   üöÄ D√©but du rollback...\n');
  }

  try {
    // Phase 1: Analyse des donn√©es √† restaurer
    await analyzeDataToRollback();

    // Phase 2: Rollback des concerts
    if (stats.concertsToRollback > 0) {
      await rollbackConcerts();
    } else {
      console.log('‚úÖ Aucun concert √† restaurer trouv√©');
    }

    // Phase 3: V√©rification post-rollback
    if (!DRY_RUN && stats.concertsRolledBack > 0) {
      await verifyRollback();
    }

    // Rapport final
    printFinalReport();

  } catch (error) {
    console.error('‚ùå Erreur fatale during rollback:', error);
    process.exit(1);
  }
}

/**
 * Analyse les donn√©es √† restaurer
 */
async function analyzeDataToRollback() {
  console.log('üîç Phase 1: Analyse des donn√©es √† restaurer...');

  try {
    const allConcertsSnapshot = await getDocs(collection(db, 'concerts'));
    stats.totalConcerts = allConcertsSnapshot.size;

    const concertsToRollback = [];
    
    allConcertsSnapshot.forEach(doc => {
      const data = doc.data();
      const hasContactIds = data.contactIds && Array.isArray(data.contactIds) && data.contactIds.length > 0;
      const hasBackup = data.contactId_migrated;
      const noContactId = !data.contactId;

      // Concert migr√© : a contactIds, pas de contactId, et une sauvegarde
      if (hasContactIds && noContactId && hasBackup) {
        concertsToRollback.push({
          id: doc.id,
          contactIds: data.contactIds,
          contactId_migrated: data.contactId_migrated,
          nom: data.nom || 'Concert sans nom',
          date: data.date || 'Date inconnue'
        });
      }
    });

    stats.concertsToRollback = concertsToRollback.length;

    console.log(`   üìä Concerts totaux: ${stats.totalConcerts}`);
    console.log(`   ‚è™ Concerts √† restaurer: ${stats.concertsToRollback}`);

    if (VERBOSE && concertsToRollback.length > 0) {
      console.log('\n   üìã Liste des concerts √† restaurer:');
      concertsToRollback.forEach((concert, index) => {
        console.log(`      ${index + 1}. ${concert.nom} (${concert.id})`);
        console.log(`         contactIds: [${concert.contactIds.join(', ')}] ‚Üí contactId: ${concert.contactId_migrated}`);
        if (concert.contactIds.length > 1) {
          console.log(`         ‚ö†Ô∏è  ${concert.contactIds.length - 1} contact(s) seront perdus !`);
        }
      });
    }

    return concertsToRollback;

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'analyse:', error);
    throw error;
  }
}

/**
 * Effectue le rollback des concerts
 */
async function rollbackConcerts() {
  console.log('\n‚è™ Phase 2: Rollback des concerts...');

  try {
    // R√©cup√©rer les concerts migr√©s
    const concertsQuery = query(
      collection(db, 'concerts'),
      where('contactIds', '!=', null)
    );
    const concertsSnapshot = await getDocs(concertsQuery);

    const batches = [];
    let currentBatch = [];

    for (const docSnapshot of concertsSnapshot.docs) {
      const concertData = docSnapshot.data();
      
      // V√©rifier si rollback n√©cessaire
      if (concertData.contactIds && 
          concertData.contactIds.length > 0 && 
          !concertData.contactId && 
          concertData.contactId_migrated) {
        
        currentBatch.push({
          id: docSnapshot.id,
          data: concertData
        });

        if (currentBatch.length >= BATCH_SIZE) {
          batches.push([...currentBatch]);
          currentBatch = [];
        }
      }
    }

    if (currentBatch.length > 0) {
      batches.push(currentBatch);
    }

    // Rollback par lots
    for (let i = 0; i < batches.length; i++) {
      await rollbackBatch(batches[i], i + 1, batches.length);
    }

  } catch (error) {
    console.error('‚ùå Erreur lors du rollback:', error);
    throw error;
  }
}

/**
 * Rollback d'un lot de concerts
 */
async function rollbackBatch(batch, batchNumber, totalBatches) {
  console.log(`   üì¶ Lot ${batchNumber}/${totalBatches} (${batch.length} concerts)`);

  if (DRY_RUN) {
    for (const concert of batch) {
      const firstContact = concert.data.contactIds[0];
      const lostContacts = concert.data.contactIds.length - 1;
      
      console.log(`      üß™ [DRY-RUN] Concert ${concert.data.nom}`);
      console.log(`         contactIds=[${concert.data.contactIds.join(', ')}] ‚Üí contactId=${concert.data.contactId_migrated}`);
      if (lostContacts > 0) {
        console.log(`         ‚ö†Ô∏è  ${lostContacts} contact(s) seraient perdus`);
      }
      stats.concertsRolledBack++;
    }
    return;
  }

  // Rollback r√©el
  const firestoreBatch = writeBatch(db);

  for (const concert of batch) {
    try {
      const concertRef = doc(db, 'concerts', concert.id);
      
      const updateData = {
        contactId: concert.data.contactId_migrated,
        contactIds: null, // Supprimer les contactIds
        contactId_migrated: null, // Nettoyer la sauvegarde
        updatedAt: serverTimestamp()
      };

      firestoreBatch.update(concertRef, updateData);

      if (VERBOSE) {
        console.log(`      ‚úÖ Concert ${concert.data.nom} pr√©par√© pour rollback`);
        if (concert.data.contactIds.length > 1) {
          console.log(`         ‚ö†Ô∏è  ${concert.data.contactIds.length - 1} contact(s) perdus`);
        }
      }

      stats.concertsRolledBack++;

    } catch (error) {
      console.error(`      ‚ùå Erreur concert ${concert.id}:`, error);
      stats.errors.push({
        concertId: concert.id,
        error: error.message
      });
    }
  }

  try {
    await firestoreBatch.commit();
    console.log(`      ‚úÖ Lot ${batchNumber} restaur√© avec succ√®s`);

    // Mettre √† jour les relations bidirectionnelles
    for (const concert of batch) {
      await updateBidirectionalRelationRollback(concert.id, concert.data.contactIds, concert.data.contactId_migrated);
    }

  } catch (error) {
    console.error(`      ‚ùå Erreur lors du commit du lot ${batchNumber}:`, error);
    throw error;
  }
}

/**
 * Met √† jour les relations bidirectionnelles pour le rollback
 */
async function updateBidirectionalRelationRollback(concertId, oldContactIds, newContactId) {
  try {
    // Supprimer le concert de tous les anciens contacts
    for (const contactId of oldContactIds) {
      const contactRef = doc(db, 'contacts', contactId);
      const contactDoc = await getDoc(contactRef);

      if (contactDoc.exists()) {
        const contactData = contactDoc.data();
        let concertsIds = contactData.concertsIds || [];

        // Supprimer l'ID du concert
        concertsIds = concertsIds.filter(id => id !== concertId);

        if (!DRY_RUN) {
          await updateDoc(contactRef, {
            concertsIds: concertsIds,
            updatedAt: serverTimestamp()
          });
        }

        if (VERBOSE) {
          console.log(`      üîó Relation supprim√©e: contact ${contactId} ‚Üî concert ${concertId}`);
        }
      }
    }

    // Ajouter le concert au nouveau contact principal
    const newContactRef = doc(db, 'contacts', newContactId);
    const newContactDoc = await getDoc(newContactRef);

    if (newContactDoc.exists()) {
      const contactData = newContactDoc.data();
      let concertsIds = contactData.concertsIds || [];

      if (!concertsIds.includes(concertId)) {
        concertsIds.push(concertId);

        if (!DRY_RUN) {
          await updateDoc(newContactRef, {
            concertsIds: concertsIds,
            updatedAt: serverTimestamp()
          });
        }

        stats.bidirectionalUpdates++;

        if (VERBOSE) {
          console.log(`      üîó Relation ajout√©e: contact ${newContactId} ‚Üî concert ${concertId}`);
        }
      }
    }

  } catch (error) {
    console.error(`      ‚ùå Erreur relation bidirectionnelle rollback:`, error);
    stats.errors.push({
      type: 'bidirectional_rollback',
      concertId,
      error: error.message
    });
  }
}

/**
 * V√©rifie le rollback
 */
async function verifyRollback() {
  console.log('\nüîç Phase 3: V√©rification post-rollback...');

  try {
    const concertsWithContactId = query(
      collection(db, 'concerts'),
      where('contactId', '!=', null)
    );
    const verifySnapshot = await getDocs(concertsWithContactId);

    let rolledBackCount = 0;
    let stillHaveContactIds = 0;

    verifySnapshot.forEach(doc => {
      const data = doc.data();
      if (data.contactId && typeof data.contactId === 'string') {
        rolledBackCount++;
      }
      if (data.contactIds && Array.isArray(data.contactIds) && data.contactIds.length > 0) {
        stillHaveContactIds++;
      }
    });

    console.log(`   ‚úÖ Concerts avec contactId: ${rolledBackCount}`);
    console.log(`   ‚ö†Ô∏è  Concerts avec encore contactIds: ${stillHaveContactIds}`);

  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification:', error);
  }
}

/**
 * Rapport final
 */
function printFinalReport() {
  console.log('\nüìã RAPPORT FINAL DE ROLLBACK');
  console.log('==============================');
  console.log(`Mode d'ex√©cution: ${DRY_RUN ? 'DRY-RUN (simulation)' : 'LIVE'}`);
  console.log(`Concerts totaux: ${stats.totalConcerts}`);
  console.log(`Concerts √† restaurer: ${stats.concertsToRollback}`);
  console.log(`Concerts restaur√©s: ${stats.concertsRolledBack}`);
  console.log(`Relations bidirectionnelles mises √† jour: ${stats.bidirectionalUpdates}`);
  console.log(`Erreurs: ${stats.errors.length}`);

  if (stats.errors.length > 0) {
    console.log('\n‚ùå ERREURS RENCONTR√âES:');
    stats.errors.forEach((error, index) => {
      console.log(`   ${index + 1}. ${error.concertId || error.type}: ${error.error}`);
    });
  }

  if (DRY_RUN) {
    console.log('\nüß™ Ceci √©tait une simulation. Relancez sans --dry-run pour appliquer le rollback.');
  } else if (stats.concertsRolledBack > 0) {
    console.log('\n‚úÖ Rollback termin√© !');
    console.log('   ‚ö†Ô∏è  Le syst√®me est revenu √† contactId (un seul contact par concert)');
    console.log('   ‚ö†Ô∏è  Les contacts suppl√©mentaires ont √©t√© perdus');
  }
}

/**
 * Point d'entr√©e
 */
if (require.main === module) {
  rollbackConcertContacts()
    .then(() => {
      console.log('üéâ Rollback termin√©');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = {
  rollbackConcertContacts
};